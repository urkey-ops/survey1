<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Customer Feedback Survey</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìù</text></svg>" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        
        .emoji-radio-group input[type="radio"]:checked + label,
        .number-scale-group input[type="radio"]:checked + label {
            transform: scale(1.1);
            box-shadow: 0 4px 14px rgba(0,0,0,0.1);
            border-color: #3b82f6;
        }
        
        .star-rating input[type="radio"] {
            display: none;
        }
        .star-rating label.star {
            cursor: pointer;
            color: #d1d5db;
            transition: color 0.2s ease, transform 0.2s ease;
        }
        .star-rating input[type="radio"]:checked ~ label.star,
        .star-rating:hover input[type="radio"]:checked ~ label.star {
            color: #f59e0b;
        }
        .star-rating label.star:hover,
        .star-rating label.star:hover ~ label.star,
        .star-rating input[type="radio"]:checked ~ label.star:hover {
            color: #fcd34d;
        }
        
        #syncButton.hidden, #adminClearButton.hidden {
            display: none;
        }
        
        .checkmark-container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            animation: fadeIn 0.5s ease-in-out;
        }
        .checkmark-circle {
            background-color: #22c55e;
            border-radius: 50%;
            width: 100px;
            height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            transform: scale(0);
            animation: bounceIn 0.8s forwards;
            animation-delay: 0.2s;
        }
        .checkmark-icon {
            color: white;
            font-size: 64px;
            font-weight: bold;
            animation: pulse 1.5s infinite;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes bounceIn {
            0% { transform: scale(0); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .sync-loading {
            animation: pulse 1.5s infinite;
        }

        .location-radio-group input[type="radio"]:checked + label {
            border-color: #3b82f6;
            background-color: #e2e8f0;
        }

        /* Visually hidden class for accessibility */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4 sm:p-6 lg:p-8">

    <div class="w-full max-w-lg mx-auto bg-white p-6 sm:p-8 rounded-2xl shadow-xl relative">
        <h1 id="mainTitle" class="text-3xl font-bold text-center text-gray-800 mb-2 cursor-pointer">Customer Feedback</h1>
        <p class="text-center text-gray-500 mb-6">We'd love to hear about your experience.</p>
        
        <button id="syncButton" class="hidden absolute top-4 right-4 text-white text-sm font-semibold bg-blue-500 hover:bg-blue-600 rounded-lg shadow-md px-4 py-2 transition-colors duration-200">
            Sync Data
        </button>
        <button id="adminClearButton" class="hidden absolute top-4 left-4 text-white text-xs font-semibold bg-red-500 hover:bg-red-600 rounded-lg shadow-md px-2 py-1 transition-colors duration-200">
            Clear Queue
        </button>

        <div id="statusMessage" class="hidden text-sm" aria-live="polite"></div>

        <div id="surveyContent">
            <div id="progressBarContainer" class="w-full bg-gray-200 rounded-full h-2.5 mb-6">
                <div id="progressBar" class="bg-blue-600 h-2.5 rounded-full transition-all duration-500 ease-in-out" style="width: 0%;"></div>
            </div>

            <form id="surveyForm" class="space-y-6">
                <div id="questionContainer"></div>
                
                <div id="survey-navigation" class="flex justify-between items-center mt-6">
                    <button id="backButton" type="button" class="px-6 py-3 text-gray-600 font-bold bg-gray-200 rounded-lg shadow-md hover:bg-gray-300 focus:outline-none focus:ring-4 focus:ring-gray-400 focus:ring-opacity-50 transition-colors" style="visibility: hidden;">
                        Back
                    </button>
                    <button id="nextButton" type="button" class="px-6 py-3 text-white font-bold bg-blue-600 rounded-lg shadow-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-500 focus:ring-opacity-50 transition-colors">
                        Next
                    </button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // --- DOM Elements & Configuration ---
        const form = document.getElementById('surveyForm');
        const statusMessage = document.getElementById('statusMessage');
        const syncButton = document.getElementById('syncButton');
        const adminClearButton = document.getElementById('adminClearButton');
        const mainTitle = document.getElementById('mainTitle');
        const nextButton = document.getElementById('nextButton');
        const backButton = document.getElementById('backButton');
        const questionContainer = document.getElementById('questionContainer');
        const surveyContent = document.getElementById('surveyContent');
        const progressBar = document.getElementById('progressBar');

        const DEBUG_MODE = true;
        const log = (message, ...args) => {
            if (DEBUG_MODE) {
                console.log(`[DEBUG] ${message}`, ...args);
            }
        };

        const config = {
            rotationSpeed: 50,
            rotationDisplayTime: 4000,
            resetTime: 5000,
            adminClicksRequired: 5,
            adminClickTimeout: 3000,
            inactivityTime: 30000,
            debounceDelay: 200,
            maxRetries: 5,
            baseDelay: 500,
        };

        const surveyQuestions = [
            {
                id: 'comments',
                name: 'comments',
                type: 'textarea',
                question: '1. What did you like about your visit today?',
                placeholder: 'Type your comments here...',
                required: true,
                rotatingText: [
                    "1. What did you like about your visit today?",
                    "1. What could we do better during your next visit?",
                    "1. Do you have any general comments or suggestions?",
                    "1. What was the most memorable part of your experience?"
                ]
            },
            {
                id: 'satisfaction',
                name: 'satisfaction',
                type: 'emoji-radio',
                question: '2. Overall, how satisfied were you with your visit today?',
                options: [
                    { value: 'Sad', label: 'Sad', emoji: 'üòû' },
                    { value: 'Neutral', label: 'Neutral', emoji: 'üòê' },
                    { value: 'Happy', label: 'Happy', emoji: 'üòä' }
                ],
                required: true
            },
            {
                id: 'cleanliness',
                name: 'cleanliness',
                type: 'number-scale',
                question: '3. How would you rate the cleanliness of the facility?',
                min: 1,
                max: 5,
                labels: { min: '1 (Poor)', max: '5 (Excellent)' },
                required: true
            },
            {
                id: 'staff_friendliness',
                name: 'staff_friendliness',
                type: 'star-rating',
                question: '4. How friendly was the volunteer staff?',
                min: 1,
                max: 5,
                required: true
            },
            {
                id: 'location',
                name: 'location',
                type: 'radio',
                question: 'Where are you visiting from today?',
                options: [
                    { value: 'Lilburn/Gwinnett County', label: 'Lilburn/Gwinnett County' },
                    { value: 'Greater Atlanta Area', label: 'Greater Atlanta Area' },
                    { value: 'Georgia (outside Atlanta)', label: 'Georgia (outside Atlanta)' },
                    { value: 'United States (outside GA)', label: 'United States (outside GA)' },
                    { value: 'Canada', label: 'Canada' },
                    { value: 'India', label: 'India' },
                    { value: 'Other', label: 'Other (please specify)' }
                ],
                required: false
            },
            {
                id: 'age',
                name: 'age',
                type: 'radio',
                question: 'Which age group do you belong to?',
                options: [
                    { value: 'Under 18', label: 'Under 18' },
                    { value: '18-34', label: '18-34' },
                    { value: '35-54', label: '35-54' },
                    { value: '55-64', label: '55-64' },
                    { value: '65+', label: '65+' }
                ],
                required: false
            },
            {
                id: 'contact',
                name: 'contact',
                type: 'checkbox-with-fields',
                question: 'Would you like to stay connected?',
                fields: [
                    { id: 'name', name: 'name', label: 'Name', type: 'text', placeholder: 'Enter your name' },
                    { id: 'email', name: 'email', label: 'Email', type: 'email', placeholder: 'Enter your email' }
                ],
                required: false
            }
        ];

        // --- Application State ---
        const appState = {
            currentPage: 0,
            formData: {},
            questionRotationIndex: 0,
            typingTimeout: null,
            displayTimeout: null,
            inactivityTimeout: null,
            isUserActive: false,
            debounceTimer: null,
            adminClickCount: 0,
            adminTimer: null,
            isTyping: false,
            stopRotationPermanently: false, // New flag
        };

        // --- Helper Functions ---
        const uuidv4 = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
            const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });

        const debounce = (func, delay) => {
            return (...args) => {
                clearTimeout(appState.debounceTimer);
                appState.debounceTimer = setTimeout(() => func.apply(this, args), delay);
            };
        };

        const updateProgressBar = () => {
            const progress = (appState.currentPage / (surveyQuestions.length - 1)) * 100;
            progressBar.style.width = `${progress}%`;
        };

        const showTemporaryMessage = (message, type = 'info') => {
            const className = type === 'error' ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700';
            statusMessage.textContent = message;
            statusMessage.className = `block p-4 mb-4 rounded-xl text-center font-medium ${className}`;
            statusMessage.style.display = 'block';
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 5000);
        };

        // --- Question Rotation Logic ---
        const startQuestionRotation = () => {
            if (appState.currentPage !== 0 || appState.stopRotationPermanently) return;
            log("Starting question rotation.");
            rotateQuestions();
        };

        const stopQuestionRotation = () => {
            log("Stopping question rotation.");
            appState.isTyping = false;
            clearTimeout(appState.typingTimeout);
            clearTimeout(appState.displayTimeout);
            appState.typingTimeout = null;
            appState.displayTimeout = null;
        };

        const handleUserActivity = () => {
            log("User activity detected.");
            clearTimeout(appState.inactivityTimeout);
            appState.isUserActive = true;
            appState.stopRotationPermanently = true; // Stop rotation for the rest of the session
            
            if (appState.currentPage === 0) {
                // Let the current typing animation finish, then stop.
                // The `typeWriter` function's check handles this.
            } else {
                stopQuestionRotation();
            }

            appState.inactivityTimeout = setTimeout(() => {
                log("User inactive. Resetting flags.");
                appState.isUserActive = false;
            }, config.inactivityTime);
        };

        const typeWriter = (text, i) => {
            const questionElement = questionContainer.querySelector('#rotatingQuestion');
            if (!questionElement) return;

            if (i < text.length) {
                questionElement.textContent += text.charAt(i);
                appState.typingTimeout = setTimeout(() => typeWriter(text, i + 1), config.rotationSpeed);
            } else {
                questionElement.textContent = text;
                appState.isTyping = false;

                if (!appState.isUserActive) {
                    appState.displayTimeout = setTimeout(rotateQuestions, config.rotationDisplayTime);
                }
            }
        };

        const rotateQuestions = () => {
            const rotatingQuestionEl = questionContainer.querySelector('#rotatingQuestion');
            if (!rotatingQuestionEl || appState.stopRotationPermanently) return;
            stopQuestionRotation();
            
            const questionData = surveyQuestions[0];
            const currentQuestion = questionData.rotatingText[appState.questionRotationIndex];
            rotatingQuestionEl.textContent = "";
            appState.questionRotationIndex = (appState.questionRotationIndex + 1) % questionData.rotatingText.length;
            typeWriter(currentQuestion, 0);
        };
        
        const debouncedHandleActivity = debounce(handleUserActivity, config.debounceDelay);

        // --- Survey Page Logic ---
        const renderPage = (pageIndex) => {
            const questionData = surveyQuestions[pageIndex];
            if (!questionData) return;

            let html = `<label class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;

            switch (questionData.type) {
                case 'textarea':
                    html = `
                        <label id="rotatingQuestion" for="${questionData.id}" class="block text-gray-700 font-semibold mb-2" aria-live="polite">${questionData.question}</label>
                        <textarea
                            id="${questionData.id}"
                            name="${questionData.name}"
                            rows="4"
                            class="shadow-sm resize-none appearance-none border border-gray-300 rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors"
                            placeholder="${questionData.placeholder}"
                            required
                        >${appState.formData[questionData.name] || ''}</textarea>
                    `;
                    break;
                case 'emoji-radio':
                    html = `<label id="${questionData.id}Label" class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;
                    html += `<div class="emoji-radio-group flex justify-around items-center space-x-4" role="radiogroup" aria-labelledby="${questionData.id}Label">`;
                    questionData.options.forEach(option => {
                        const checked = appState.formData[questionData.name] === option.value ? 'checked' : '';
                        html += `
                            <input type="radio" id="${questionData.id + option.value}" name="${questionData.name}" value="${option.value}" class="visually-hidden" ${checked} aria-label="${option.label} emoji">
                            <label for="${questionData.id + option.value}" class="flex flex-col items-center p-4 sm:p-6 bg-white border-2 border-transparent rounded-full hover:bg-gray-50 transition-all duration-300 cursor-pointer">
                                <span class="text-4xl sm:text-5xl">${option.emoji}</span>
                                <span class="mt-2 text-gray-500 text-xs sm:text-sm">${option.label}</span>
                            </label>
                        `;
                    });
                    html += `</div>`;
                    break;
                case 'number-scale':
                    html = `<label id="${questionData.id}Label" class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;
                    html += `
                        <div class="number-scale-group flex justify-between items-center bg-gray-50 rounded-lg p-4" role="radiogroup" aria-labelledby="${questionData.id}Label">
                            <span class="text-xs text-gray-500">${questionData.labels.min}</span>
                            <div class="flex space-x-2">
                    `;
                    for (let i = questionData.min; i <= questionData.max; i++) {
                        const checked = parseInt(appState.formData[questionData.name]) === i ? 'checked' : '';
                        html += `
                            <input type="radio" id="${questionData.id + i}" name="${questionData.name}" value="${i}" class="visually-hidden" ${checked} aria-label="${i}">
                            <label for="${questionData.id + i}" class="w-10 h-10 flex items-center justify-center text-sm font-medium bg-white rounded-full border border-gray-300 hover:bg-gray-100 transition-colors duration-200 cursor-pointer">${i}</label>
                        `;
                    }
                    html += `
                            </div>
                            <span class="text-xs text-gray-500">${questionData.labels.max}</span>
                        </div>
                    `;
                    break;
                case 'star-rating':
                    html = `<label id="${questionData.id}Label" class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;
                    html += `<div class="star-rating flex flex-row-reverse justify-end space-x-1 sm:space-x-2" role="radiogroup" aria-labelledby="${questionData.id}Label">`;
                    for (let i = questionData.max; i >= questionData.min; i--) {
                        const checked = parseInt(appState.formData[questionData.name]) === i ? 'checked' : '';
                        html += `
                            <input type="radio" id="${questionData.id + i}" name="${questionData.name}" value="${i}" ${checked} aria-label="${i} stars">
                            <label for="${questionData.id + i}" class="star">
                                <svg class="w-8 h-8 sm:w-10 sm:h-10 fill-current" viewBox="0 0 24 24"><path d="M12 17.27l6.18 3.73-1.64-7.03 5.46-4.73-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73-1.64 7.03z"/></svg>
                            </label>
                        `;
                    }
                    html += `</div>`;
                    break;
                case 'radio':
                    html = `<label id="${questionData.id}Label" class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;
                    html += `<div class="location-radio-group grid grid-cols-1 sm:grid-cols-2 gap-4" role="radiogroup" aria-labelledby="${questionData.id}Label">`;
                    questionData.options.forEach(option => {
                        const checked = appState.formData[questionData.name] === option.value ? 'checked' : '';
                        html += `
                            <div>
                                <input type="radio" id="${questionData.id + option.value}" name="${questionData.name}" value="${option.value}" class="visually-hidden" ${checked} aria-label="${option.label}">
                                <label for="${questionData.id + option.value}" class="block w-full py-4 px-6 bg-white border border-gray-300 rounded-lg text-center font-medium cursor-pointer hover:bg-gray-50 transition-colors duration-200">
                                    ${option.label}
                                </label>
                            </div>
                        `;
                    });
                    html += `</div>`;
                    break;
                case 'checkbox-with-fields':
                    html = `<p class="text-sm text-gray-500 mb-4">You can optionally provide your contact information to receive updates and news.</p>`;
                    questionData.fields.forEach(field => {
                        const value = appState.formData[field.name] || '';
                        html += `
                            <div class="mb-4">
                                <label for="${field.id}" class="block text-sm font-medium text-gray-700">${field.label}</label>
                                <input type="${field.type}" id="${field.id}" name="${field.name}" placeholder="${field.placeholder}" value="${value}" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                            </div>
                        `;
                    });
                    html += `
                        <div class="flex items-center mt-4">
                            <input id="newsletterConsent" name="newsletterConsent" type="checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" ${appState.formData.newsletterConsent === 'Yes' ? 'checked' : ''}>
                            <label for="newsletterConsent" class="ml-2 block text-sm text-gray-900">
                                Yes, I would like to subscribe to the newsletter.
                            </label>
                        </div>
                    `;
                    break;
            }
            questionContainer.innerHTML = html;
            
            backButton.style.visibility = appState.currentPage === 0 ? 'hidden' : 'visible';
            nextButton.textContent = (appState.currentPage === surveyQuestions.length - 1) ? 'Submit Survey' : 'Next';

            if (appState.currentPage === 0) {
                startQuestionRotation();
            } else {
                stopQuestionRotation();
            }
            updateProgressBar();
        };

        const saveCurrentPageData = () => {
            const formData = new FormData(form);
            const questionData = surveyQuestions[appState.currentPage];
            
            if (questionData.type === 'checkbox-with-fields') {
                appState.formData.name = formData.get('name') || '';
                appState.formData.email = formData.get('email') || '';
                appState.formData.newsletterConsent = formData.get('newsletterConsent') === 'on' ? 'Yes' : 'No';
            } else {
                appState.formData[questionData.name] = formData.get(questionData.name);
            }
        };

        const validateCurrentPage = () => {
            const questionData = surveyQuestions[appState.currentPage];
            if (!questionData.required) return true;

            const value = appState.formData[questionData.name];
            let isValid = false;
            
            if (questionData.type === 'textarea') {
                isValid = value && value.trim() !== '';
            } else {
                isValid = !!value;
            }
            
            const element = questionContainer.querySelector(`[name="${questionData.name}"]`);
            if (!isValid) {
                if (element) {
                    element.classList.add('border-red-500');
                    showTemporaryMessage('Please answer this question to continue.', 'error');
                }
            } else {
                if (element) {
                    element.classList.remove('border-red-500');
                }
            }
            return isValid;
        };

        // --- Offline-first and Sync Logic ---
        const getSurveyQueue = () => {
            try {
                const queue = JSON.parse(localStorage.getItem('surveyQueue'));
                // Filter out any items that are already scheduled for retry
                return Array.isArray(queue) ? queue.filter(item => !item.isScheduledForRetry) : [];
            } catch (e) {
                console.error("Failed to parse survey queue from localStorage.", e);
                return [];
            }
        };
        
        const saveSurveyToQueue = (data) => {
            log("Saving new survey to local queue.", data);
            const queue = getSurveyQueue();
            queue.push({ ...data, retries: 0 });
            localStorage.setItem('surveyQueue', JSON.stringify(queue));
            updateSyncButtonVisibility();
        };

        const syncData = async () => {
            const queue = getSurveyQueue();
            if (queue.length === 0 || !navigator.onLine) {
                log("Sync not needed or offline.");
                updateSyncButtonVisibility();
                return;
            }
            log(`Starting sync process for ${queue.length} items.`);
            syncButton.textContent = 'Syncing...';
            syncButton.classList.add('sync-loading');
            
            const pendingQueue = getSurveyQueue();
            const successfullySynced = [];
            const failedToSync = [];
            
            for (const surveyData of pendingQueue) {
                try {
                    const response = await fetch('/api/submit-survey', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(surveyData)
                    });
                    if (response.ok) {
                        successfullySynced.push(surveyData);
                        log(`Successfully synced item: ${surveyData.id}`);
                    } else {
                        throw new Error(`API error: ${response.status}`);
                    }
                } catch (error) {
                    log(`Sync failed for item ${surveyData.id}:`, error);
                    failedToSync.push(surveyData);
                }
            }

            // Process results and update queue
            let finalQueue = failedToSync.map(item => {
                item.retries++;
                // Check if max retries have been reached
                if (item.retries >= config.maxRetries) {
                    log(`Max retries reached for ${item.id}. Dropping.`);
                    return null;
                }
                // Calculate exponential backoff delay
                const delay = config.baseDelay * Math.pow(2, item.retries);
                log(`Scheduling retry for ${item.id} in ${delay / 1000} seconds.`);
                setTimeout(syncData, delay);
                item.isScheduledForRetry = true;
                return item;
            }).filter(Boolean); // Filter out items dropped after max retries

            localStorage.setItem('surveyQueue', JSON.stringify(finalQueue));
            syncButton.classList.remove('sync-loading');
            updateSyncButtonVisibility(failedToSync.length > 0);

            if (finalQueue.length === 0) {
                showTemporaryMessage('Sync successful! All data uploaded.');
            } else if (successfullySynced.length > 0) {
                showTemporaryMessage(`Synced ${successfullySynced.length} of ${queue.length} surveys. Some will be retried later.`);
            } else {
                showTemporaryMessage('Sync failed. Please check your internet connection.', 'error');
            }
        };

        const updateSyncButtonVisibility = (hasFailed = false) => {
            const queue = getSurveyQueue();
            if (queue.length > 0 && navigator.onLine) {
                syncButton.classList.remove('hidden');
                syncButton.textContent = `Sync Data (${queue.length})`;
                if (hasFailed) {
                    syncButton.textContent += ' (‚ö†Ô∏è)';
                }
            } else {
                syncButton.classList.add('hidden');
            }
        };
        
        const clearQueue = () => {
            const queue = getSurveyQueue();
            if (queue.length > 0) {
                if (confirm(`Are you sure you want to clear ${queue.length} unsynced submissions? This action cannot be undone.`)) {
                    log("Admin confirmed clear queue. Removing data.");
                    localStorage.removeItem('surveyQueue');
                    updateSyncButtonVisibility();
                    showTemporaryMessage('Unsynced data cleared.');
                }
            } else {
                log("No unsynced data to clear.");
                showTemporaryMessage('No unsynced data to clear.');
            }
        };

        const scheduleDailySync = () => {
            const now = new Date();
            const syncTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 19, 0, 0);
            if (now > syncTime) {
                syncTime.setDate(syncTime.getDate() + 1);
            }
            const delay = syncTime.getTime() - now.getTime();
            log(`Scheduled next sync for ${syncTime.toLocaleString()}. Delay: ${delay / 1000} seconds.`);
            setTimeout(syncData, delay);
        };

        // --- Event Listeners & Initialization ---
        nextButton.addEventListener('click', () => {
            saveCurrentPageData();
            if (!validateCurrentPage()) {
                return;
            }

            if (appState.currentPage === surveyQuestions.length - 1) {
                form.dispatchEvent(new Event('submit', { cancelable: true }));
            } else {
                appState.currentPage++;
                renderPage(appState.currentPage);
            }
        });

        backButton.addEventListener('click', () => {
            if (appState.currentPage > 0) {
                appState.currentPage--;
                statusMessage.style.display = 'none';
                renderPage(appState.currentPage);
            }
        });

        syncButton.addEventListener('click', syncData);

        mainTitle.addEventListener('click', () => {
            appState.adminClickCount++;
            if (appState.adminClickCount === 1) {
                appState.adminTimer = setTimeout(() => {
                    appState.adminClickCount = 0;
                }, config.adminClickTimeout);
            } else if (appState.adminClickCount >= config.adminClicksRequired) {
                clearTimeout(appState.adminTimer);
                appState.adminClickCount = 0;
                adminClearButton.classList.toggle('hidden');
                showTemporaryMessage('Admin button toggled.');
            }
        });

        adminClearButton.addEventListener('click', clearQueue);

        form.addEventListener('submit', async (e) => {
            e.preventDefault();

            // Add client-side timestamp
            const finalData = { ...appState.formData, id: uuidv4(), timestamp: new Date().toISOString() };
            log("Form submitted. Saving to queue.", finalData);
            saveSurveyToQueue(finalData);
            
            surveyContent.style.display = 'none';
            statusMessage.style.display = 'block';
            statusMessage.innerHTML = `
                <div class="checkmark-container">
                    <div class="checkmark-circle">
                        <span class="checkmark-icon">&#10003;</span>
                    </div>
                    <h2 class="text-2xl sm:text-3xl font-bold text-gray-800 mt-6">Thank you!</h2>
                    <p class="text-gray-500 mt-2">Your feedback has been submitted.</p>
                </div>
            `;
            
            const rotatingQuestion = surveyQuestions[0].rotatingText[appState.questionRotationIndex];
            const resetDelay = appState.isTyping ? (config.rotationSpeed * rotatingQuestion.length) + 1000 : config.resetTime;

            setTimeout(() => {
                statusMessage.style.display = 'none';
                surveyContent.style.display = 'block';
                form.reset();
                appState.currentPage = 0;
                appState.formData = {};
                appState.isUserActive = false;
                appState.stopRotationPermanently = false; // Reset the flag
                renderPage(appState.currentPage);
            }, resetDelay);
        });

        form.addEventListener('change', (e) => {
            const name = e.target.name;
            const value = e.target.value;
            
            if (surveyQuestions[appState.currentPage].type === 'checkbox-with-fields') {
                saveCurrentPageData();
            } else {
                appState.formData[name] = value;
            }

            if (e.target.type === 'radio') {
                saveCurrentPageData();
                if(validateCurrentPage()){
                    nextButton.click();
                }
            }
        });
        
        // Listen for keyboard input on the comments textarea
        document.addEventListener('keydown', (e) => {
            const commentsTextarea = document.getElementById('comments');
            if (commentsTextarea && document.activeElement === commentsTextarea) {
                debouncedHandleActivity();
            }
        });

        // Use more general event listeners for overall activity
        document.addEventListener('mousemove', debouncedHandleActivity);
        document.addEventListener('mousedown', debouncedHandleActivity);
        document.addEventListener('touchstart', debouncedHandleActivity);

        window.addEventListener('online', syncData);
        window.addEventListener('offline', updateSyncButtonVisibility);

        // Initial setup
        renderPage(appState.currentPage);
        updateSyncButtonVisibility();
        scheduleDailySync();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Customer Feedback Survey</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìù</text></svg>" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        
        .emoji-radio-group input[type="radio"]:checked + label,
        .number-scale-group input[type="radio"]:checked + label {
            transform: scale(1.1);
            box-shadow: 0 4px 14px rgba(0,0,0,0.1);
            border-color: #3b82f6;
        }
        
        .star-rating input[type="radio"] {
            display: none;
        }
        .star-rating label.star {
            cursor: pointer;
            color: #d1d5db;
            transition: color 0.2s ease, transform 0.2s ease;
        }
        .star-rating input[type="radio"]:checked ~ label.star,
        .star-rating:hover input[type="radio"]:checked ~ label.star {
            color: #f59e0b;
        }
        .star-rating label.star:hover,
        .star-rating label.star:hover ~ label.star,
        .star-rating input[type="radio"]:checked ~ label.star:hover {
            color: #fcd34d;
        }
        
        #syncButton.hidden, #adminClearButton.hidden {
            display: none;
        }
        
        .checkmark-container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            animation: fadeIn 0.5s ease-in-out;
        }
        .checkmark-circle {
            background-color: #22c55e;
            border-radius: 50%;
            width: 100px;
            height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            transform: scale(0);
            animation: bounceIn 0.8s forwards;
            animation-delay: 0.2s;
        }
        .checkmark-icon {
            color: white;
            font-size: 64px;
            font-weight: bold;
            animation: pulse 1.5s infinite;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes bounceIn {
            0% { transform: scale(0); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .sync-loading {
            animation: pulse 1.5s infinite;
        }

        .location-radio-group input[type="radio"]:checked + label {
            border-color: #3b82f6;
            background-color: #e2e8f0;
        }

        /* Visually hidden class for accessibility */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
        .hidden-fields {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-out;
        }
        .visible-fields {
            max-height: 500px; /* Large enough to accommodate the fields */
            transition: max-height 0.5s ease-in;
        }
        .has-error {
            border-color: #ef4444; /* red-500 */
        }
        .error-message {
            color: #ef4444; /* red-500 */
            font-size: 0.875rem; /* text-sm */
            margin-top: 0.25rem; /* mt-1 */
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.7);
            z-index: 10;
            display: none;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s ease;
            flex-direction: column; /* Add flex-direction to stack content */
        }
        .overlay.visible {
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4 sm:p-6 lg:p-8">
    <div id="overlay" class="overlay" role="status" aria-live="polite">
        <p id="overlayMessage">Survey auto-submitting in <span id="countdown">5</span> seconds...</p>
        <button id="cancelButton" class="mt-4 px-6 py-2 bg-red-500 text-white rounded-lg shadow-md hover:bg-red-600 transition-colors hidden" aria-label="Cancel auto-submit countdown">
            Cancel
        </button>
    </div>

    <div class="w-full max-w-lg mx-auto bg-white p-6 sm:p-8 rounded-2xl shadow-xl relative">
        <h1 id="mainTitle" class="text-3xl font-bold text-center text-gray-800 mb-2 cursor-pointer">Customer Feedback</h1>
        <p class="text-center text-gray-500 mb-6">We'd love to hear about your experience.</p>
        
        <button id="syncButton" class="hidden absolute top-4 right-4 text-white text-sm font-semibold bg-blue-500 hover:bg-blue-600 rounded-lg shadow-md px-4 py-2 transition-colors duration-200">
            Sync Data
        </button>
        <button id="adminClearButton" class="hidden absolute top-4 left-4 text-white text-xs font-semibold bg-red-500 hover:bg-red-600 rounded-lg shadow-md px-2 py-1 transition-colors duration-200">
            Clear Queue
        </button>

        <div id="statusMessage" class="hidden text-sm" aria-live="polite"></div>

        <div id="surveyContent">
            <div id="progressBarContainer" class="w-full bg-gray-200 rounded-full h-2.5 mb-6">
                <div id="progressBar" class="bg-blue-600 h-2.5 rounded-full transition-all duration-500 ease-in-out" style="width: 0%;"></div>
            </div>

            <form id="surveyForm" class="space-y-6">
                <div id="questionContainer"></div>
                
                <div id="survey-navigation" class="flex justify-between items-center mt-6">
                    <button id="backButton" type="button" class="px-6 py-3 text-gray-600 font-bold bg-gray-200 rounded-lg shadow-md hover:bg-gray-300 focus:outline-none focus:ring-4 focus:ring-gray-400 focus:ring-opacity-50 transition-colors" style="visibility: hidden;">
                        Back
                    </button>
                    <button id="nextButton" type="button" class="px-6 py-3 text-white font-bold bg-blue-600 rounded-lg shadow-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-500 focus:ring-opacity-50 transition-colors">
                        Next
                    </button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // --- DOM Elements & Configuration ---
        const form = document.getElementById('surveyForm');
        const statusMessage = document.getElementById('statusMessage');
        const syncButton = document.getElementById('syncButton');
        const adminClearButton = document.getElementById('adminClearButton');
        const mainTitle = document.getElementById('mainTitle');
        const nextButton = document.getElementById('nextButton');
        const backButton = document.getElementById('backButton');
        const questionContainer = document.getElementById('questionContainer');
        const surveyContent = document.getElementById('surveyContent');
        const overlay = document.getElementById('overlay');
        const overlayMessage = document.getElementById('overlayMessage');
        const countdownSpan = document.getElementById('countdown');
        const cancelButton = document.getElementById('cancelButton');

        const DEBUG_MODE = true;
        const log = (message, ...args) => {
            if (DEBUG_MODE) {
                console.log(`[DEBUG] ${message}`, ...args);
            }
        };

        const config = {
            rotationSpeed: 50,
            rotationDisplayTime: 4000,
            resetTime: 5000,
            adminClicksRequired: 5,
            adminClickTimeout: 3000,
            inactivityTime: 30000, // 30 seconds
            autoSubmitCountdown: 5, // 5-second countdown
            debounceDelay: 200,
            maxRetries: 5,
            baseDelay: 500,
        };

        const surveyQuestions = [
            {
                id: 'comments',
                name: 'comments',
                type: 'textarea',
                question: '1. What did you like about your visit today?',
                placeholder: 'Type your comments here...',
                required: true,
                rotatingText: [
                    "1. What did you like about your visit today?",
                    "1. What could we do better during your next visit?",
                    "1. Do you have any general comments or suggestions?",
                    "1. What was the most memorable part of your experience?"
                ]
            },
            {
                id: 'satisfaction',
                name: 'satisfaction',
                type: 'emoji-radio',
                question: '2. Overall, how satisfied were you with your visit today?',
                options: [
                    { value: 'Sad', label: 'Sad', emoji: 'üòû' },
                    { value: 'Neutral', label: 'Neutral', emoji: 'üòê' },
                    { value: 'Happy', label: 'Happy', emoji: 'üòä' }
                ],
                required: true
            },
            {
                id: 'cleanliness',
                name: 'cleanliness',
                type: 'number-scale',
                question: '3. How would you rate the cleanliness of the facility?',
                min: 1,
                max: 5,
                labels: { min: '1 (Poor)', max: '5 (Excellent)' },
                required: true
            },
            {
                id: 'staff_friendliness',
                name: 'staff_friendliness',
                type: 'star-rating',
                question: '4. How friendly was the volunteer staff?',
                min: 1,
                max: 5,
                required: true
            },
            {
                id: 'location',
                name: 'location',
                type: 'radio-with-other',
                question: 'Where are you visiting from today?',
                options: [
                    { value: 'Lilburn/Gwinnett County', label: 'Lilburn/Gwinnett County' },
                    { value: 'Greater Atlanta Area', label: 'Greater Atlanta Area' },
                    { value: 'Georgia (outside Atlanta)', label: 'Georgia (outside Atlanta)' },
                    { value: 'United States (outside GA)', label: 'United States (outside GA)' },
                    { value: 'Canada', label: 'Canada' },
                    { value: 'India', label: 'India' },
                    { value: 'Other', label: 'Other' }
                ],
                required: false
            },
            {
                id: 'age',
                name: 'age',
                type: 'radio',
                question: 'Which age group do you belong to?',
                options: [
                    { value: 'Under 18', label: 'Under 18' },
                    { value: '18-40', label: '18-40' },
                    { value: '40-65', label: '40-65' },
                    { value: '65+', label: '65+' }
                ],
                required: false
            },
            {
                id: 'contact',
                name: 'contact',
                type: 'custom-contact',
                question: 'Help us stay in touch.',
                required: false,
                fields: [
                    { id: 'name', name: 'name', label: 'Name', type: 'text', placeholder: 'Enter your name' },
                    { id: 'newsletterConsent', name: 'newsletterConsent', label: 'Yes, I want to subscribe to updates', type: 'checkbox', placeholder: '' },
                    { id: 'email', name: 'email', label: 'Email', type: 'email', placeholder: 'Enter your email' }
                ]
            }
        ];

        // --- Application State ---
        const appState = {
            currentPage: 0,
            formData: {},
            questionRotationIndex: 0,
            typingTimeout: null,
            displayTimeout: null,
            inactivityTimeout: null, 
            countdownInterval: null,
            isUserActive: false,
            debounceTimer: null,
            adminClickCount: 0,
            adminTimer: null,
            isTyping: false,
            stopRotationPermanently: false,
            stopRotationOnCompletion: false,
        };

        // --- Helper Functions ---
        const uuidv4 = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
            const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });

        const debounce = (func, delay) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func(...args), delay);
            };
        };

        const updateProgressBar = () => {
            const progress = (appState.currentPage / (surveyQuestions.length - 1)) * 100;
            progressBar.style.width = `${progress}%`;
        };

        const showTemporaryMessage = (message, type = 'info') => {
            const className = type === 'error' ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700';
            statusMessage.textContent = message;
            statusMessage.className = `block p-4 mb-4 rounded-xl text-center font-medium ${className}`;
            statusMessage.style.display = 'block';
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 5000);
        };
        
        const resetRadioAndCheckboxStates = () => {
            const radioButtons = document.querySelectorAll('input[type="radio"]');
            radioButtons.forEach(input => {
                input.checked = false;
            });
            const checkboxes = document.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(input => {
                input.checked = false;
            });
        };

        // --- Question Rotation Logic ---
        const startQuestionRotation = () => {
            if (appState.currentPage !== 0 || appState.stopRotationPermanently) return;
            log("Starting question rotation.");
            rotateQuestions();
        };

        const stopQuestionRotation = () => {
            log("Stopping question rotation.");
            appState.isTyping = false;
            clearTimeout(appState.typingTimeout);
            clearTimeout(appState.displayTimeout);
            appState.typingTimeout = null;
            appState.displayTimeout = null;
        };
        
        // Inactivity Timer & Countdown Logic
        const clearCountdown = () => {
            clearInterval(appState.countdownInterval);
            appState.countdownInterval = null;
            if (countdownSpan) {
                countdownSpan.textContent = config.autoSubmitCountdown;
            }
        };
        
        const cancelAutoSubmit = () => {
            log("User activity detected during countdown. Aborting auto-submit.");
            clearTimeout(appState.inactivityTimeout);
            clearCountdown();
            
            overlayMessage.textContent = "Countdown Canceled. Please continue with your survey.";
            cancelButton.classList.add('hidden');
            
            // Immediately restart the inactivity timer on cancel
            handleUserActivity();

            setTimeout(() => {
                toggleUserInteraction(true);
                overlayMessage.innerHTML = 'Survey auto-submitting in <span id="countdown">5</span> seconds...';
            }, 1500); // Give user a moment to read the message
        }

        const handleUserActivity = () => {
            // First, cancel any pending auto-submit or countdown
            clearTimeout(appState.inactivityTimeout);
            clearCountdown();
            
            log("User activity detected. Resetting inactivity timer.");
            appState.isUserActive = true;
            appState.stopRotationPermanently = true;
            
            if (appState.currentPage !== 0) {
                stopQuestionRotation();
            }

            appState.inactivityTimeout = setTimeout(() => {
                log("User inactive. Triggering auto-submit.");
                autoSubmitSurvey();
            }, config.inactivityTime);
        };

        const typeWriter = (text, i) => {
            const questionElement = questionContainer.querySelector('#rotatingQuestion');
            if (!questionElement) {
                log("Rotation element not found, stopping rotation.");
                return;
            }

            if (i < text.length) {
                questionElement.textContent += text.charAt(i);
                appState.typingTimeout = setTimeout(() => typeWriter(text, i + 1), config.rotationSpeed);
            } else {
                questionElement.textContent = text;
                appState.isTyping = false;
                
                // New logic to handle deferred stopping
                if (appState.stopRotationOnCompletion) {
                    log("Typing completed, stopping rotation as requested by user interaction.");
                    stopQuestionRotation();
                    appState.stopRotationOnCompletion = false;
                } else if (!appState.isUserActive) {
                    appState.displayTimeout = setTimeout(rotateQuestions, config.rotationDisplayTime);
                }
            }
        };

        const rotateQuestions = () => {
            const rotatingQuestionEl = questionContainer.querySelector('#rotatingQuestion');
            if (!rotatingQuestionEl || appState.stopRotationPermanently) return;
            stopQuestionRotation();
            
            const questionData = surveyQuestions[0];
            const currentQuestion = questionData.rotatingText[appState.questionRotationIndex];
            rotatingQuestionEl.textContent = "";
            appState.questionRotationIndex = (appState.questionRotationIndex + 1) % questionData.rotatingText.length;
            typeWriter(currentQuestion, 0);
        };
        
        const debouncedHandleActivity = debounce(handleUserActivity, config.debounceDelay);
        const debouncedValidate = debounce(runValidation, 500);

        // --- Survey Page Logic ---
        const renderPage = (pageIndex) => {
            resetRadioAndCheckboxStates();
            
            const questionData = surveyQuestions[pageIndex];
            if (!questionData) return;

            let html = '';

            switch (questionData.type) {
                case 'textarea':
                    html = `
                        <label id="rotatingQuestion" for="${questionData.id}" class="block text-gray-700 font-semibold mb-2" aria-live="polite">${questionData.question}</label>
                        <textarea
                            id="${questionData.id}"
                            name="${questionData.name}"
                            rows="4"
                            class="shadow-sm resize-none appearance-none border border-gray-300 rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors"
                            placeholder="${questionData.placeholder}"
                            required
                        >${appState.formData[questionData.name] || ''}</textarea>
                        <span id="${questionData.id}Error" class="error-message hidden"></span>
                    `;
                    break;
                case 'emoji-radio':
                    html = `<label id="${questionData.id}Label" class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;
                    html += `<div class="emoji-radio-group flex justify-around items-center space-x-4" role="radiogroup" aria-labelledby="${questionData.id}Label">`;
                    questionData.options.forEach(option => {
                        const checked = appState.formData[questionData.name] === option.value ? 'checked' : '';
                        html += `
                            <input type="radio" id="${questionData.id + option.value}" name="${questionData.name}" value="${option.value}" class="visually-hidden" ${checked} aria-label="${option.label} emoji">
                            <label for="${questionData.id + option.value}" class="flex flex-col items-center p-4 sm:p-6 bg-white border-2 border-transparent rounded-full hover:bg-gray-50 transition-all duration-300 cursor-pointer">
                                <span class="text-4xl sm:text-5xl mb-2">${option.emoji}</span>
                                <span class="text-sm font-medium text-gray-600">${option.label}</span>
                            </label>
                        `;
                    });
                    html += `</div><span id="${questionData.id}Error" class="error-message hidden mt-2 block"></span>`;
                    break;
                case 'number-scale':
                    html = `<label id="${questionData.id}Label" class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;
                    html += `<div class="number-scale-group flex justify-between items-center space-x-2" role="radiogroup" aria-labelledby="${questionData.id}Label">`;
                    for (let i = questionData.min; i <= questionData.max; i++) {
                        const checked = parseInt(appState.formData[questionData.name]) === i ? 'checked' : '';
                        html += `
                            <input type="radio" id="${questionData.id + i}" name="${questionData.name}" value="${i}" class="visually-hidden" ${checked} aria-label="Rating of ${i}">
                            <label for="${questionData.id + i}" class="flex flex-col items-center justify-center w-12 h-12 sm:w-14 sm:h-14 bg-white border-2 border-transparent rounded-full font-bold text-gray-700 hover:bg-gray-50 transition-colors duration-300 cursor-pointer">
                                <span>${i}</span>
                            </label>
                        `;
                    }
                    html += `</div>
                             <div class="flex justify-between text-sm mt-2 text-gray-500">
                                 <span>${questionData.labels.min}</span>
                                 <span>${questionData.labels.max}</span>
                             </div>
                             <span id="${questionData.id}Error" class="error-message hidden mt-2 block"></span>
                            `;
                    break;
                case 'star-rating':
                    html = `<label id="${questionData.id}Label" class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;
                    html += `<div class="star-rating flex flex-row-reverse justify-center mt-2" role="radiogroup" aria-labelledby="${questionData.id}Label">`;
                    for (let i = questionData.max; i >= questionData.min; i--) {
                        const checked = parseInt(appState.formData[questionData.name]) === i ? 'checked' : '';
                        html += `
                            <input type="radio" id="${questionData.id + i}" name="${questionData.name}" value="${i}" ${checked} aria-label="${i} stars">
                            <label for="${questionData.id + i}" class="star text-4xl sm:text-5xl pr-1">‚òÖ</label>
                        `;
                    }
                    html += `</div><span id="${questionData.id}Error" class="error-message hidden mt-2 block"></span>`;
                    break;
                case 'radio-with-other':
                    html = `<label id="${questionData.id}Label" class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;
                    html += `<div class="location-radio-group grid grid-cols-2 sm:grid-cols-3 gap-2" role="radiogroup" aria-labelledby="${questionData.id}Label">`;
                    questionData.options.forEach(option => {
                        const checked = appState.formData[questionData.name] === option.value ? 'checked' : '';
                        html += `
                            <input type="radio" id="${questionData.id + option.value}" name="${questionData.name}" value="${option.value}" class="visually-hidden" ${checked}>
                            <label for="${questionData.id + option.value}" class="px-3 py-3 text-center text-sm sm:text-base font-medium border-2 border-gray-300 rounded-lg cursor-pointer transition-colors duration-200">${option.label}</label>
                        `;
                    });
                    html += `</div>
                            <div id="other-location-container" class="mt-4 ${appState.formData[questionData.name] === 'Other' ? '' : 'hidden'}">
                                <input type="text" id="other_location_text" name="other_location" class="shadow-sm appearance-none border border-gray-300 rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors" placeholder="Please specify your location" value="${appState.formData['other_location'] || ''}">
                                <span id="other_location_textError" class="error-message hidden mt-1"></span>
                            </div>
                            <span id="${questionData.id}Error" class="error-message hidden mt-2 block"></span>`;
                    break;
                case 'radio':
                    html = `<label id="${questionData.id}Label" class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;
                    html += `<div class="grid grid-cols-2 sm:grid-cols-4 gap-2" role="radiogroup" aria-labelledby="${questionData.id}Label">`;
                    questionData.options.forEach(option => {
                        const checked = appState.formData[questionData.name] === option.value ? 'checked' : '';
                        html += `
                            <input type="radio" id="${questionData.id + option.value}" name="${questionData.name}" value="${option.value}" class="visually-hidden" ${checked}>
                            <label for="${questionData.id + option.value}" class="px-3 py-3 text-center text-sm sm:text-base font-medium border-2 border-gray-300 rounded-lg cursor-pointer transition-colors duration-200">${option.label}</label>
                        `;
                    });
                    html += `</div><span id="${questionData.id}Error" class="error-message hidden mt-2 block"></span>`;
                    break;
                case 'custom-contact':
                    const nameValue = appState.formData['name'] || '';
                    const newsletterConsentChecked = appState.formData['newsletterConsent'] === 'Yes' ? 'checked' : '';
                    const emailValue = appState.formData['email'] || '';
                    const emailFieldVisibleClass = newsletterConsentChecked ? 'visible-fields' : 'hidden-fields';
                    
                    html = `
                        <div class="space-y-4">
                            <div>
                                <label for="name" class="block text-gray-700 font-semibold mb-2">Name</label>
                                <input type="text" id="name" name="name" class="shadow-sm appearance-none border border-gray-300 rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors" placeholder="Enter your name" value="${nameValue}" required>
                                <span id="nameError" class="error-message hidden"></span>
                            </div>
                            <div class="flex items-center">
                                <input type="checkbox" id="newsletterConsent" name="newsletterConsent" value="Yes" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" ${newsletterConsentChecked}>
                                <label for="newsletterConsent" class="ml-2 block text-gray-700">Yes, I want to subscribe to updates</label>
                            </div>
                            <div id="email-field-container" class="${emailFieldVisibleClass}">
                                <label for="email" class="block text-gray-700 font-semibold mb-2">Email</label>
                                <input type="email" id="email" name="email" class="shadow-sm appearance-none border border-gray-300 rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors" placeholder="Enter your email" value="${emailValue}">
                                <span id="emailError" class="error-message hidden"></span>
                            </div>
                        </div>
                    `;
                    break;
            }

            questionContainer.innerHTML = html;
            updateProgressBar();

            if (pageIndex === 0) {
                if (!appState.isUserActive) {
                    startQuestionRotation();
                }
            } else {
                stopQuestionRotation();
            }

            if (pageIndex === surveyQuestions.length - 1) {
                nextButton.textContent = 'Submit Survey';
            } else {
                nextButton.textContent = 'Next';
            }

            backButton.style.visibility = pageIndex === 0 ? 'hidden' : 'visible';
            setupEventListeners();
        };

        const clearValidationErrors = () => {
            const errorSpans = questionContainer.querySelectorAll('.error-message');
            errorSpans.forEach(span => {
                span.classList.add('hidden');
                span.textContent = '';
            });
            const errorInputs = questionContainer.querySelectorAll('.has-error');
            errorInputs.forEach(input => {
                input.classList.remove('has-error');
            });
        };
        
        const showValidationError = (fieldId, message) => {
            const errorSpan = document.getElementById(`${fieldId}Error`);
            const fieldInput = document.getElementById(fieldId);
            if (errorSpan) {
                errorSpan.textContent = message;
                errorSpan.classList.remove('hidden');
            }
            if (fieldInput) {
                fieldInput.classList.add('has-error');
            }
            // For radio/checkbox groups, find the parent to apply error class
            if (!fieldInput && errorSpan) {
                const parentGroup = errorSpan.closest('.emoji-radio-group, .number-scale-group, .star-rating, .location-radio-group');
                if (parentGroup) {
                    parentGroup.classList.add('has-error');
                }
            }
        };

        const validatePage = () => {
            const questionData = surveyQuestions[appState.currentPage];
            const errors = {};
            
            const currentPageData = {};
            const inputs = questionContainer.querySelectorAll('input, textarea');
            inputs.forEach(input => {
                if (input.type === 'radio' && input.checked) {
                    currentPageData[input.name] = input.value;
                } else if (input.type === 'checkbox') {
                    currentPageData[input.name] = input.checked ? 'Yes' : 'No';
                } else if (input.type !== 'radio') {
                    currentPageData[input.name] = input.value;
                }
            });

            // Specific validation based on question type
            if (questionData.type === 'textarea') {
                const value = currentPageData[questionData.name]?.trim();
                if (questionData.required && (!value || value.length === 0)) {
                    errors[questionData.id] = 'This field is required.';
                }
            } else if (questionData.type === 'emoji-radio' || questionData.type === 'number-scale' || questionData.type === 'radio' || questionData.type === 'star-rating') {
                if (questionData.required && !currentPageData[questionData.name]) {
                    errors[questionData.id] = 'Please make a selection.';
                }
            } else if (questionData.type === 'radio-with-other') {
                const selectedValue = currentPageData[questionData.name];
                const otherLocationValue = currentPageData['other_location']?.trim();

                if (selectedValue === 'Other' && (!otherLocationValue || otherLocationValue.length === 0)) {
                    errors['other_location_text'] = 'Please specify your location.';
                }
            } else if (questionData.type === 'custom-contact') {
                const nameValue = currentPageData['name']?.trim();
                const newsletterConsent = currentPageData['newsletterConsent'] === 'Yes';
                const emailValue = currentPageData['email']?.trim();
                
                if (!nameValue || nameValue.length === 0) {
                    errors['name'] = 'Name is required.';
                }
                
                if (newsletterConsent && (!emailValue || emailValue.length === 0)) {
                    errors['email'] = 'Email is required for subscription.';
                } else if (emailValue && !/^\S+@\S+\.\S+$/.test(emailValue)) {
                    errors['email'] = 'Please enter a valid email address.';
                }
            }

            // Save valid data, and display errors
            clearValidationErrors();
            if (Object.keys(errors).length > 0) {
                for (const fieldId in errors) {
                    showValidationError(fieldId, errors[fieldId]);
                }
                return false;
            } else {
                Object.assign(appState.formData, currentPageData);
                log("Current form data:", appState.formData);
                return true;
            }
        };

        function runValidation() {
            validatePage();
        }

        const toggleEmailFieldVisibility = (isVisible) => {
            const emailContainer = document.getElementById('email-field-container');
            const emailInput = document.getElementById('email');
            
            if (isVisible) {
                emailContainer.classList.remove('hidden-fields');
                emailContainer.classList.add('visible-fields');
                emailInput.setAttribute('required', 'true');
            } else {
                emailContainer.classList.remove('visible-fields');
                emailContainer.classList.add('hidden-fields');
                emailInput.removeAttribute('required');
                emailInput.value = ''; // Clear the email value if the field is hidden
            }
        };

        const setupEventListeners = () => {
            const questionData = surveyQuestions[appState.currentPage];
            
            // Clear all existing listeners on question container inputs
            const inputs = questionContainer.querySelectorAll('input, textarea');
            inputs.forEach(input => {
                input.removeEventListener('input', debouncedHandleActivity);
                input.removeEventListener('change', debouncedHandleActivity);
                input.removeEventListener('blur', debouncedValidate);
                input.removeEventListener('change', debouncedValidate);
            });
            form.removeEventListener('keydown', debouncedHandleActivity);
            form.removeEventListener('click', debouncedHandleActivity);

            // Reattach new listeners
            if (questionData.type === 'textarea') {
                const textarea = document.getElementById('comments');
                if (textarea) {
                    textarea.addEventListener('focus', () => {
                        appState.stopRotationOnCompletion = true;
                    });
                    textarea.addEventListener('blur', () => {
                        startQuestionRotation();
                        debouncedValidate();
                    });
                }
            } else if (questionData.type === 'radio-with-other') {
                const otherRadio = document.getElementById('locationOther');
                const otherLocationContainer = document.getElementById('other-location-container');
                const allRadios = document.querySelectorAll('input[name="location"]');
                if (otherRadio) {
                    allRadios.forEach(radio => {
                        radio.addEventListener('change', () => {
                            if (otherRadio.checked) {
                                otherLocationContainer.classList.remove('hidden');
                            } else {
                                otherLocationContainer.classList.add('hidden');
                            }
                            debouncedValidate();
                        });
                    });
                }
            } else if (questionData.type === 'custom-contact') {
                const newsletterCheckbox = document.getElementById('newsletterConsent');
                if (newsletterCheckbox) {
                    newsletterCheckbox.addEventListener('change', (e) => {
                        toggleEmailFieldVisibility(e.target.checked);
                        debouncedValidate();
                    });
                }
                // Handle initial state of email field
                if (newsletterCheckbox) {
                    toggleEmailFieldVisibility(newsletterCheckbox.checked);
                }
            }
            
            // Reattach activity and validation listeners for all inputs on the page
            inputs.forEach(input => {
                input.addEventListener('input', debouncedHandleActivity);
                input.addEventListener('change', debouncedHandleActivity);
                
                if (input.type === 'text' || input.type === 'textarea' || input.type === 'email') {
                    input.addEventListener('blur', debouncedValidate);
                } else if (input.type === 'radio' || input.type === 'checkbox') {
                    input.addEventListener('change', debouncedValidate);
                }
            });
            
            // Handle form input on-screen
            form.addEventListener('keydown', debouncedHandleActivity);
            form.addEventListener('click', debouncedHandleActivity);
        };

        const autoSubmitSurvey = () => {
            if (appState.currentPage === 0 && Object.keys(appState.formData).length === 0) {
                log("User inactive on first page with no data. Resetting survey.");
                resetSurvey();
                return;
            }

            log("Starting auto-submit countdown.");
            
            let countdown = config.autoSubmitCountdown;
            countdownSpan.textContent = countdown;
            toggleUserInteraction(false);
            overlay.classList.add('visible');
            cancelButton.classList.remove('hidden');

            cancelButton.addEventListener('click', cancelAutoSubmit, { once: true });

            appState.countdownInterval = setInterval(() => {
                countdown--;
                if (countdownSpan) {
                    countdownSpan.textContent = countdown;
                }
                if (countdown <= 0) {
                    clearCountdown();
                    toggleUserInteraction(false, "Submitting...");
                    submitSurvey();
                }
            }, 1000);
        };
        
        const submitSurvey = async () => {
            try {
                toggleUserInteraction(false, "Submitting data...");
                log("Submitting form data:", appState.formData);

                const response = await fetch('/api/submit-survey', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(appState.formData),
                });

                if (!response.ok) {
                    throw new Error('Network response was not ok.');
                }

                const result = await response.json();
                log('API Response:', result);

                showCompletionScreen();
                
            } catch (error) {
                console.error('Submission failed:', error);
                showTemporaryMessage('Submission failed. Please try again or inform staff.', 'error');
                toggleUserInteraction(true);
            }
        };

        const showCompletionScreen = () => {
            surveyContent.innerHTML = `
                <div class="checkmark-container min-h-[300px]">
                    <div class="checkmark-circle">
                        <div class="checkmark-icon">‚úì</div>
                    </div>
                    <h2 class="text-2xl font-bold text-gray-800 mt-6">Thank You!</h2>
                    <p class="text-gray-600 mt-2">Your feedback has been submitted successfully.</p>
                </div>
            `;
            // Reset after a delay
            setTimeout(() => {
                resetSurvey();
            }, config.resetTime);
        };

        const resetSurvey = () => {
            log("Resetting survey.");
            appState.currentPage = 0;
            appState.formData = {};
            appState.isUserActive = false;
            appState.stopRotationPermanently = false;
            overlay.classList.remove('visible');
            overlayMessage.innerHTML = 'Survey auto-submitting in <span id="countdown">5</span> seconds...';
            cancelButton.classList.add('hidden');
            form.reset();
            clearCountdown(); // Ensure any ongoing countdown is stopped on reset.
            renderPage(appState.currentPage);
            
            // Re-enable user interaction
            toggleUserInteraction(true);
            // Restart the inactivity timer on fresh load
            handleUserActivity();
        };

        const toggleUserInteraction = (enable, message = "") => {
            if (enable) {
                surveyContent.classList.remove('pointer-events-none', 'opacity-50');
                overlay.classList.remove('visible');
            } else {
                surveyContent.classList.add('pointer-events-none', 'opacity-50');
                if (message) {
                    overlayMessage.innerHTML = message;
                    overlay.classList.add('visible');
                }
            }
        };

        // --- Event Handlers ---
        nextButton.addEventListener('click', (e) => {
            e.preventDefault();
            if (validatePage()) {
                if (appState.currentPage < surveyQuestions.length - 1) {
                    appState.currentPage++;
                    renderPage(appState.currentPage);
                } else {
                    submitSurvey();
                }
            }
        });

        backButton.addEventListener('click', (e) => {
            e.preventDefault();
            if (appState.currentPage > 0) {
                appState.currentPage--;
                renderPage(appState.currentPage);
            }
        });

        mainTitle.addEventListener('click', () => {
            appState.adminClickCount++;
            if (appState.adminTimer) {
                clearTimeout(appState.adminTimer);
            }
            appState.adminTimer = setTimeout(() => {
                appState.adminClickCount = 0;
            }, config.adminClickTimeout);

            if (appState.adminClickCount === config.adminClicksRequired) {
                log("Admin mode activated!");
                showTemporaryMessage("Admin mode activated.");
                syncButton.classList.remove('hidden');
                adminClearButton.classList.remove('hidden');
                appState.adminClickCount = 0;
                clearTimeout(appState.adminTimer);
            }
        });
        
        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            renderPage(appState.currentPage);
            handleUserActivity(); // Start the inactivity timer on initial page load
        });
    </script>
</body>
</html>

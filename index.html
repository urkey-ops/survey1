<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Customer Feedback Survey</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìù</text></svg>" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        input[type="radio"]:checked + label {
            transform: scale(1.1);
            box-shadow: 0 4px 14px rgba(0,0,0,0.1);
            border-color: #3b82f6;
        }
        .star-rating input[type="radio"] {
            display: none;
        }
        .star-rating label.star {
            cursor: pointer;
            color: #d1d5db;
            transition: color 0.2s ease, transform 0.2s ease;
        }
        .star-rating input[type="radio"]:checked ~ label.star,
        .star-rating:hover input[type="radio"]:checked ~ label.star {
            color: #f59e0b;
        }
        .star-rating label.star:hover,
        .star-rating label.star:hover ~ label.star,
        .star-rating input[type="radio"]:checked ~ label.star:hover {
            color: #fcd34d;
        }
        #syncButton.hidden, #adminClearButton.hidden {
            display: none;
        }
        /* Checkmark Animation Styles */
        .checkmark-container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            animation: fadeIn 0.5s ease-in-out;
        }
        .checkmark-circle {
            background-color: #22c55e;
            border-radius: 50%;
            width: 100px;
            height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            transform: scale(0);
            animation: bounceIn 0.8s forwards;
            animation-delay: 0.2s;
        }
        .checkmark-icon {
            color: white;
            font-size: 64px;
            font-weight: bold;
            animation: pulse 1.5s infinite;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes bounceIn {
            0% { transform: scale(0); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .sync-loading {
            animation: pulse 1.5s infinite;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4 sm:p-6 lg:p-8">

    <div class="w-full max-w-lg mx-auto bg-white p-6 sm:p-8 rounded-2xl shadow-xl relative">
        <h1 id="mainTitle" class="text-3xl font-bold text-center text-gray-800 mb-2 cursor-pointer">Customer Feedback</h1>
        <p class="text-center text-gray-500 mb-6">We'd love to hear about your experience.</p>
        
        <button id="syncButton" class="hidden absolute top-4 right-4 text-white text-sm font-semibold bg-blue-500 hover:bg-blue-600 rounded-lg shadow-md px-4 py-2 transition-colors duration-200">
            Sync Data
        </button>
        <button id="adminClearButton" class="hidden absolute top-4 left-4 text-white text-xs font-semibold bg-red-500 hover:bg-red-600 rounded-lg shadow-md px-2 py-1 transition-colors duration-200">
            Clear Queue
        </button>

        <div id="statusMessage" class="hidden text-sm"></div>

        <div id="surveyContent">
            <div id="progressBarContainer" class="w-full bg-gray-200 rounded-full h-2.5 mb-6">
                <div id="progressBar" class="bg-blue-600 h-2.5 rounded-full transition-all duration-500 ease-in-out" style="width: 0%;"></div>
            </div>

            <form id="surveyForm" class="space-y-6">
                <div id="questionContainer"></div>
                
                <div id="survey-navigation" class="flex justify-between items-center mt-6">
                    <button id="backButton" type="button" class="px-6 py-3 text-gray-600 font-bold bg-gray-200 rounded-lg shadow-md hover:bg-gray-300 focus:outline-none focus:ring-4 focus:ring-gray-400 focus:ring-opacity-50 transition-colors" style="visibility: hidden;">
                        Back
                    </button>
                    <button id="nextButton" type="button" class="px-6 py-3 text-white font-bold bg-blue-600 rounded-lg shadow-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-500 focus:ring-opacity-50 transition-colors">
                        Next
                    </button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // --- DOM Elements & Configuration ---
        const form = document.getElementById('surveyForm');
        const statusMessage = document.getElementById('statusMessage');
        const syncButton = document.getElementById('syncButton');
        const adminClearButton = document.getElementById('adminClearButton');
        const mainTitle = document.getElementById('mainTitle');
        const nextButton = document.getElementById('nextButton');
        const backButton = document.getElementById('backButton');
        const questionContainer = document.getElementById('questionContainer');
        const surveyContent = document.getElementById('surveyContent');
        const progressBar = document.getElementById('progressBar');

        const DEBUG_MODE = true;
        const log = (message, ...args) => {
            if (DEBUG_MODE) {
                console.log(`[DEBUG] ${message}`, ...args);
            }
        };

        const config = {
            rotationSpeed: 50,
            rotationDisplayTime: 4000,
            resetTime: 5000,
            adminClicksRequired: 5,
            adminClickTimeout: 3000,
            inactivityTime: 30000,
            debounceDelay: 200,
        };

        const surveyQuestions = [
            {
                id: 'comments',
                name: 'comments',
                type: 'textarea',
                question: '1. What did you like about your visit today?',
                placeholder: 'Type your comments here...',
                required: true,
                rotatingText: [
                    "1. What did you like about your visit today?",
                    "1. What could we do better during your next visit?",
                    "1. Do you have any general comments or suggestions?",
                    "1. What was the most memorable part of your experience?"
                ]
            },
            {
                id: 'satisfaction',
                name: 'satisfaction',
                type: 'emoji-radio',
                question: '2. Overall, how satisfied were you with your visit today?',
                options: [
                    { value: 'Sad', label: 'Sad', emoji: 'üòû' },
                    { value: 'Neutral', label: 'Neutral', emoji: 'üòê' },
                    { value: 'Happy', label: 'Happy', emoji: 'üòä' }
                ],
                required: true
            },
            {
                id: 'cleanliness',
                name: 'cleanliness',
                type: 'number-scale',
                question: '3. How would you rate the cleanliness of the facility?',
                min: 1,
                max: 5,
                labels: { min: '1 (Poor)', max: '5 (Excellent)' },
                required: true
            },
            {
                id: 'staff_friendliness',
                name: 'staff_friendliness',
                type: 'star-rating',
                question: '4. How friendly was the volunteer staff?',
                min: 1,
                max: 5,
                required: true
            }
        ];

        // --- Application State ---
        const appState = {
            currentPage: 0,
            formData: {},
            questionRotationIndex: 0,
            typingTimeout: null,
            displayTimeout: null,
            inactivityTimeout: null,
            isUserActive: false,
            debounceTimer: null,
            adminClickCount: 0,
            adminTimer: null
        };

        // --- Helper Functions ---
        const uuidv4 = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
            const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });

        const debounce = (func, delay) => {
            return (...args) => {
                clearTimeout(appState.debounceTimer);
                appState.debounceTimer = setTimeout(() => func.apply(this, args), delay);
            };
        };

        const updateProgressBar = () => {
            const progress = (appState.currentPage / (surveyQuestions.length - 1)) * 100;
            progressBar.style.width = `${progress}%`;
        };

        const showTemporaryMessage = (message, type = 'info') => {
            const className = type === 'error' ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700';
            statusMessage.textContent = message;
            statusMessage.className = `block p-4 mb-4 rounded-xl text-center font-medium ${className}`;
            statusMessage.style.display = 'block';
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 5000);
        };

        // --- Question Rotation Logic ---
        const startQuestionRotation = () => {
            if (appState.currentPage !== 0 || appState.isUserActive) return;
            log("Starting question rotation.");
            rotateQuestions();
        };

        const stopQuestionRotation = () => {
            log("Stopping question rotation.");
            clearTimeout(appState.typingTimeout);
            clearTimeout(appState.displayTimeout);
            appState.typingTimeout = null;
            appState.displayTimeout = null;
        };

        const handleUserActivity = () => {
            log("User activity detected. Pausing rotation.");
            appState.isUserActive = true;
            stopQuestionRotation();
            clearTimeout(appState.inactivityTimeout);
            appState.inactivityTimeout = setTimeout(() => {
                log("User inactive. Resetting flag and starting rotation.");
                appState.isUserActive = false;
                startQuestionRotation();
            }, config.inactivityTime);
        };

        const typeWriter = (text, i) => {
            const questionElement = questionContainer.querySelector('#rotatingQuestion');
            if (i < text.length) {
                questionElement.textContent += text.charAt(i);
                appState.typingTimeout = setTimeout(() => typeWriter(text, i + 1), config.rotationSpeed);
            } else {
                if (!appState.isUserActive) {
                    appState.displayTimeout = setTimeout(rotateQuestions, config.rotationDisplayTime);
                }
            }
        };

        const rotateQuestions = () => {
            const rotatingQuestionEl = questionContainer.querySelector('#rotatingQuestion');
            if (!rotatingQuestionEl) return;
            stopQuestionRotation();
            if (appState.isUserActive) {
                return;
            }
            const questionData = surveyQuestions[0];
            const currentQuestion = questionData.rotatingText[appState.questionRotationIndex];
            rotatingQuestionEl.textContent = "";
            appState.questionRotationIndex = (appState.questionRotationIndex + 1) % questionData.rotatingText.length;
            typeWriter(currentQuestion, 0);
        };
        const debouncedHandleActivity = debounce(handleUserActivity, config.debounceDelay);

        // --- Survey Page Logic ---
        const renderPage = (pageIndex) => {
            const questionData = surveyQuestions[pageIndex];
            if (!questionData) return;

            let html = `<label class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;

            switch (questionData.type) {
                case 'textarea':
                    html = `
                        <label id="rotatingQuestion" class="block text-gray-700 font-semibold mb-2" aria-live="polite"></label>
                        <textarea
                            id="${questionData.id}"
                            name="${questionData.name}"
                            rows="4"
                            class="shadow-sm resize-none appearance-none border border-gray-300 rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors"
                            placeholder="${questionData.placeholder}"
                            required
                        >${appState.formData[questionData.name] || ''}</textarea>
                    `;
                    break;
                case 'emoji-radio':
                    html += `<div class="flex justify-around items-center space-x-4">`;
                    questionData.options.forEach(option => {
                        const checked = appState.formData[questionData.name] === option.value ? 'checked' : '';
                        html += `
                            <input type="radio" id="${questionData.id + option.value}" name="${questionData.name}" value="${option.value}" class="hidden" ${checked}>
                            <label for="${questionData.id + option.value}" class="flex flex-col items-center p-4 sm:p-6 bg-white border-2 border-transparent rounded-full hover:bg-gray-50 transition-all duration-300 cursor-pointer">
                                <span class="text-4xl sm:text-5xl">${option.emoji}</span>
                                <span class="mt-2 text-gray-500 text-xs sm:text-sm">${option.label}</span>
                            </label>
                        `;
                    });
                    html += `</div>`;
                    break;
                case 'number-scale':
                    html += `
                        <div class="flex justify-between items-center bg-gray-50 rounded-lg p-4">
                            <span class="text-xs text-gray-500">${questionData.labels.min}</span>
                            <div class="flex space-x-2">
                    `;
                    for (let i = questionData.min; i <= questionData.max; i++) {
                        const checked = parseInt(appState.formData[questionData.name]) === i ? 'checked' : '';
                        html += `
                            <input type="radio" id="${questionData.id + i}" name="${questionData.name}" value="${i}" class="hidden" ${checked}>
                            <label for="${questionData.id + i}" class="w-10 h-10 flex items-center justify-center text-sm font-medium bg-white rounded-full border border-gray-300 hover:bg-gray-100 transition-colors duration-200 cursor-pointer">${i}</label>
                        `;
                    }
                    html += `
                            </div>
                            <span class="text-xs text-gray-500">${questionData.labels.max}</span>
                        </div>
                    `;
                    break;
                case 'star-rating':
                    html += `<div class="star-rating flex flex-row-reverse justify-end space-x-1 sm:space-x-2">`;
                    for (let i = questionData.max; i >= questionData.min; i--) {
                        const checked = parseInt(appState.formData[questionData.name]) === i ? 'checked' : '';
                        html += `
                            <input type="radio" id="${questionData.id + i}" name="${questionData.name}" value="${i}" ${checked}>
                            <label for="${questionData.id + i}" class="star">
                                <svg class="w-8 h-8 sm:w-10 sm:h-10 fill-current" viewBox="0 0 24 24"><path d="M12 17.27l6.18 3.73-1.64-7.03 5.46-4.73-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73-1.64 7.03z"/></svg>
                            </label>
                        `;
                    }
                    html += `</div>`;
                    break;
            }
            questionContainer.innerHTML = html;
            
            backButton.style.visibility = appState.currentPage === 0 ? 'hidden' : 'visible';
            nextButton.textContent = (appState.currentPage === surveyQuestions.length - 1) ? 'Submit Survey' : 'Next';

            if (appState.currentPage === 0) {
                startQuestionRotation();
            } else {
                stopQuestionRotation();
            }
            updateProgressBar();
        };

        const saveCurrentPageData = () => {
            const formData = new FormData(form);
            const questionData = surveyQuestions[appState.currentPage];
            const value = formData.get(questionData.name);
            appState.formData[questionData.name] = value;
        };

        const validateCurrentPage = () => {
            const questionData = surveyQuestions[appState.currentPage];
            if (!questionData.required) return true;

            const value = appState.formData[questionData.name];
            let isValid = false;
            
            if (questionData.type === 'textarea') {
                isValid = value && value.trim() !== '';
            } else {
                isValid = !!value;
            }
            
            const element = questionContainer.querySelector(`[name="${questionData.name}"]`);
            if (!isValid) {
                if (element) {
                    element.classList.add('border-red-500');
                    showTemporaryMessage('Please answer this question to continue.', 'error');
                }
            } else {
                if (element) {
                    element.classList.remove('border-red-500');
                }
            }
            return isValid;
        };

        // --- Offline-first and Sync Logic ---
        const getSurveyQueue = () => {
            try {
                const queue = JSON.parse(localStorage.getItem('surveyQueue'));
                return Array.isArray(queue) ? queue : [];
            } catch (e) {
                console.error("Failed to parse survey queue from localStorage.", e);
                return [];
            }
        };

        const saveSurveyToQueue = (data) => {
            log("Saving new survey to local queue.", data);
            const queue = getSurveyQueue();
            queue.push(data);
            localStorage.setItem('surveyQueue', JSON.stringify(queue));
            updateSyncButtonVisibility();
        };

        const syncData = async () => {
            const queue = getSurveyQueue();
            if (queue.length === 0 || !navigator.onLine) {
                log("Sync not needed or offline.");
                updateSyncButtonVisibility();
                return;
            }
            log(`Starting sync process for ${queue.length} items.`);
            syncButton.textContent = 'Syncing...';
            syncButton.classList.add('sync-loading');
            
            const remainingSubmissions = [...queue];
            let successfullySyncedCount = 0;
            let failedToSync = false;

            for (const surveyData of remainingSubmissions) {
                try {
                    const response = await fetch('/api/submit-survey', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(surveyData)
                    });
                    if (response.ok) {
                        successfullySyncedCount++;
                        log(`Successfully synced item: ${surveyData.id}`);
                        const indexToRemove = queue.findIndex(item => item.id === surveyData.id);
                        if (indexToRemove !== -1) {
                            queue.splice(indexToRemove, 1);
                        }
                    } else {
                        log(`API responded with an error for item ${surveyData.id}: ${response.status}`);
                        failedToSync = true;
                    }
                } catch (error) {
                    log(`Network or API Error for item ${surveyData.id}:`, error);
                    failedToSync = true;
                }
            }
            
            localStorage.setItem('surveyQueue', JSON.stringify(queue));
            syncButton.classList.remove('sync-loading');
            updateSyncButtonVisibility(failedToSync);

            if (queue.length === 0) {
                showTemporaryMessage('Sync successful! All data uploaded.');
            } else if (successfullySyncedCount > 0) {
                showTemporaryMessage(`Synced ${successfullySyncedCount} of ${remainingSubmissions.length} surveys. Some failed and were kept in the queue.`);
            } else {
                showTemporaryMessage('Sync failed. Please check your internet connection.', 'error');
            }
        };

        const updateSyncButtonVisibility = (failedToSync = false) => {
            const queue = getSurveyQueue();
            if (queue.length > 0 && navigator.onLine) {
                syncButton.classList.remove('hidden');
                syncButton.textContent = `Sync Data (${queue.length})`;
                if (failedToSync) {
                    syncButton.textContent += ' (‚ö†Ô∏è)';
                }
            } else {
                syncButton.classList.add('hidden');
            }
        };
        
        const clearQueue = () => {
            const queue = getSurveyQueue();
            if (queue.length > 0) {
                if (confirm(`Are you sure you want to clear ${queue.length} unsynced submissions? This action cannot be undone.`)) {
                    log("Admin confirmed clear queue. Removing data.");
                    localStorage.removeItem('surveyQueue');
                    updateSyncButtonVisibility();
                    showTemporaryMessage('Unsynced data cleared.');
                }
            } else {
                log("No unsynced data to clear.");
                showTemporaryMessage('No unsynced data to clear.');
            }
        };

        const scheduleDailySync = () => {
            const now = new Date();
            const syncTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 19, 0, 0);
            if (now > syncTime) {
                syncTime.setDate(syncTime.getDate() + 1);
            }
            const delay = syncTime.getTime() - now.getTime();
            log(`Scheduled next sync for ${syncTime.toLocaleString()}. Delay: ${delay / 1000} seconds.`);
            setTimeout(syncData, delay);
        };

        // --- Event Listeners & Initialization ---
        nextButton.addEventListener('click', () => {
            saveCurrentPageData();
            if (!validateCurrentPage()) {
                return;
            }

            if (appState.currentPage === surveyQuestions.length - 1) {
                form.dispatchEvent(new Event('submit', { cancelable: true }));
            } else {
                appState.currentPage++;
                renderPage(appState.currentPage);
            }
        });

        backButton.addEventListener('click', () => {
            if (appState.currentPage > 0) {
                appState.currentPage--;
                statusMessage.style.display = 'none';
                renderPage(appState.currentPage);
            }
        });

        syncButton.addEventListener('click', syncData);

        mainTitle.addEventListener('click', () => {
            appState.adminClickCount++;
            if (appState.adminClickCount === 1) {
                appState.adminTimer = setTimeout(() => {
                    appState.adminClickCount = 0;
                }, config.adminClickTimeout);
            } else if (appState.adminClickCount >= config.adminClicksRequired) {
                clearTimeout(appState.adminTimer);
                appState.adminClickCount = 0;
                adminClearButton.classList.toggle('hidden');
                showTemporaryMessage('Admin button toggled.');
            }
        });

        adminClearButton.addEventListener('click', clearQueue);

        form.addEventListener('submit', async (e) => {
            e.preventDefault();

            const finalData = { ...appState.formData, id: uuidv4() };
            log("Form submitted. Saving to queue.", finalData);
            saveSurveyToQueue(finalData);
            
            surveyContent.style.display = 'none';
            statusMessage.style.display = 'block';
            statusMessage.innerHTML = `
                <div class="checkmark-container">
                    <div class="checkmark-circle">
                        <span class="checkmark-icon">&#10003;</span>
                    </div>
                    <h2 class="text-2xl sm:text-3xl font-bold text-gray-800 mt-6">Thank you!</h2>
                    <p class="text-gray-500 mt-2">Your feedback has been submitted.</p>
                </div>
            `;
            
            setTimeout(() => {
                statusMessage.style.display = 'none';
                surveyContent.style.display = 'block';
                form.reset();
                appState.currentPage = 0;
                appState.formData = {};
                renderPage(appState.currentPage);
            }, config.resetTime);
        });

        form.addEventListener('change', (e) => {
            const name = e.target.name;
            const value = e.target.value;
            appState.formData[name] = value;
            if (e.target.type === 'radio') {
                saveCurrentPageData();
                if(validateCurrentPage()){
                    nextButton.click();
                }
            }
        });

        document.addEventListener('mousemove', debouncedHandleActivity);
        document.addEventListener('mousedown', debouncedHandleActivity);
        document.addEventListener('keydown', debouncedHandleActivity);
        document.addEventListener('touchstart', debouncedHandleActivity);
        document.addEventListener('touchend', debouncedHandleActivity);

        window.addEventListener('online', syncData);
        window.addEventListener('offline', updateSyncButtonVisibility);

        // Initial setup
        renderPage(appState.currentPage);
        updateSyncButtonVisibility();
        scheduleDailySync();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Customer Feedback Survey</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìù</text></svg>" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        
        .emoji-radio-group input[type="radio"]:checked + label,
        .number-scale-group input[type="radio"]:checked + label {
            transform: scale(1.1);
            box-shadow: 0 4px 14px rgba(0,0,0,0.1);
            border-color: #3b82f6;
        }
        
        .star-rating input[type="radio"] {
            display: none;
        }
        .star-rating label.star {
            cursor: pointer;
            color: #d1d5db;
            transition: color 0.2s ease, transform 0.2s ease;
        }
        .star-rating input[type="radio"]:checked ~ label.star,
        .star-rating:hover input[type="radio"]:checked ~ label.star {
            color: #f59e0b;
        }
        .star-rating label.star:hover,
        .star-rating label.star:hover ~ label.star,
        .star-rating input[type="radio"]:checked ~ label.star:hover {
            color: #fcd34d;
        }
        
        #syncButton.hidden, #adminClearButton.hidden {
            display: none;
        }
        
        .checkmark-container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            animation: fadeIn 0.5s ease-in-out;
        }
        .checkmark-circle {
            background-color: #22c55e;
            border-radius: 50%;
            width: 100px;
            height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            transform: scale(0);
            animation: bounceIn 0.8s forwards;
            animation-delay: 0.2s;
        }
        .checkmark-icon {
            color: white;
            font-size: 64px;
            font-weight: bold;
            animation: pulse 1.5s infinite;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes bounceIn {
            0% { transform: scale(0); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .sync-loading {
            animation: pulse 1.5s infinite;
        }

        .location-radio-group input[type="radio"]:checked + label {
            border-color: #3b82f6;
            background-color: #e2e8f0;
        }

        /* Visually hidden class for accessibility */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
        .hidden-fields {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-out;
        }
        .visible-fields {
            max-height: 500px; /* Large enough to accommodate the fields */
            transition: max-height 0.5s ease-in;
        }
        .has-error {
            border-color: #ef4444; /* red-500 */
        }
        .error-message {
            color: #ef4444; /* red-500 */
            font-size: 0.875rem; /* text-sm */
            margin-top: 0.25rem; /* mt-1 */
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.7);
            z-index: 10;
            display: none;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s ease;
            flex-direction: column; /* Add flex-direction to stack content */
        }
        .overlay.visible {
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4 sm:p-6 lg:p-8">
    <div id="overlay" class="overlay" role="status" aria-live="polite">
        <p id="overlayMessage">Survey auto-submitting due to inactivity...</p>
        <button id="cancelButton" class="mt-4 px-6 py-2 bg-red-500 text-white rounded-lg shadow-md hover:bg-red-600 transition-colors hidden">
            Cancel
        </button>
    </div>

    <div class="w-full max-w-lg mx-auto bg-white p-6 sm:p-8 rounded-2xl shadow-xl relative">
        <h1 id="mainTitle" class="text-3xl font-bold text-center text-gray-800 mb-2 cursor-pointer">Customer Feedback</h1>
        <p class="text-center text-gray-500 mb-6">We'd love to hear about your experience.</p>
        
        <button id="syncButton" class="hidden absolute top-4 right-4 text-white text-sm font-semibold bg-blue-500 hover:bg-blue-600 rounded-lg shadow-md px-4 py-2 transition-colors duration-200">
            Sync Data
        </button>
        <button id="adminClearButton" class="hidden absolute top-4 left-4 text-white text-xs font-semibold bg-red-500 hover:bg-red-600 rounded-lg shadow-md px-2 py-1 transition-colors duration-200">
            Clear Queue
        </button>

        <div id="statusMessage" class="hidden text-sm" aria-live="polite"></div>

        <div id="surveyContent">
            <div id="progressBarContainer" class="w-full bg-gray-200 rounded-full h-2.5 mb-6">
                <div id="progressBar" class="bg-blue-600 h-2.5 rounded-full transition-all duration-500 ease-in-out" style="width: 0%;"></div>
            </div>

            <form id="surveyForm" class="space-y-6">
                <div id="questionContainer"></div>
                
                <div id="survey-navigation" class="flex justify-between items-center mt-6">
                    <button id="backButton" type="button" class="px-6 py-3 text-gray-600 font-bold bg-gray-200 rounded-lg shadow-md hover:bg-gray-300 focus:outline-none focus:ring-4 focus:ring-gray-400 focus:ring-opacity-50 transition-colors" style="visibility: hidden;">
                        Back
                    </button>
                    <button id="nextButton" type="button" class="px-6 py-3 text-white font-bold bg-blue-600 rounded-lg shadow-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-500 focus:ring-opacity-50 transition-colors">
                        Next
                    </button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // --- DOM Elements & Configuration ---
        const form = document.getElementById('surveyForm');
        const statusMessage = document.getElementById('statusMessage');
        const syncButton = document.getElementById('syncButton');
        const adminClearButton = document.getElementById('adminClearButton');
        const mainTitle = document.getElementById('mainTitle');
        const nextButton = document.getElementById('nextButton');
        const backButton = document.getElementById('backButton');
        const questionContainer = document.getElementById('questionContainer');
        const surveyContent = document.getElementById('surveyContent');
        const overlay = document.getElementById('overlay');
        const overlayMessage = document.getElementById('overlayMessage');
        const cancelButton = document.getElementById('cancelButton');
        const progressBar = document.getElementById('progressBar');

        const DEBUG_MODE = true;
        const log = (message, ...args) => {
            if (DEBUG_MODE) {
                console.log(`[DEBUG] ${message}`, ...args);
            }
        };

        const config = {
            rotationSpeed: 50,
            rotationDisplayTime: 4000,
            resetTime: 5000,
            adminClicksRequired: 5,
            adminClickTimeout: 3000,
            inactivityTime: 30000, // 30 seconds
            autoSubmitCountdown: 5, // 5-second countdown
            debounceDelay: 200,
            maxRetries: 5,
            baseDelay: 500,
        };

        const surveyQuestions = [
            {
                id: 'comments',
                name: 'comments',
                type: 'textarea',
                question: '1. What did you like about your visit today?',
                placeholder: 'Type your comments here...',
                required: true,
                rotatingText: [
                    "1. What did you like about your visit today?",
                    "1. What could we do better during your next visit?",
                    "1. Do you have any general comments or suggestions?",
                    "1. What was the most memorable part of your experience?"
                ]
            },
            {
                id: 'satisfaction',
                name: 'satisfaction',
                type: 'emoji-radio',
                question: '2. Overall, how satisfied were you with your visit today?',
                options: [
                    { value: 'Sad', label: 'Sad', emoji: 'üòû' },
                    { value: 'Neutral', label: 'Neutral', emoji: 'üòê' },
                    { value: 'Happy', label: 'Happy', emoji: 'üòä' }
                ],
                required: true
            },
            {
                id: 'cleanliness',
                name: 'cleanliness',
                type: 'number-scale',
                question: '3. How would you rate the cleanliness of the facility?',
                min: 1,
                max: 5,
                labels: { min: '1 (Poor)', max: '5 (Excellent)' },
                required: true
            },
            {
                id: 'staff_friendliness',
                name: 'staff_friendliness',
                type: 'star-rating',
                question: '4. How friendly was the volunteer staff?',
                min: 1,
                max: 5,
                required: true
            },
            {
                id: 'location',
                name: 'location',
                type: 'radio-with-other',
                question: 'Where are you visiting from today?',
                options: [
                    { value: 'Lilburn/Gwinnett County', label: 'Lilburn/Gwinnett County' },
                    { value: 'Greater Atlanta Area', label: 'Greater Atlanta Area' },
                    { value: 'Georgia (outside Atlanta)', label: 'Georgia (outside Atlanta)' },
                    { value: 'United States (outside GA)', label: 'United States (outside GA)' },
                    { value: 'Canada', label: 'Canada' },
                    { value: 'India', label: 'India' },
                    { value: 'Other', label: 'Other' }
                ],
                required: false
            },
            {
                id: 'age',
                name: 'age',
                type: 'radio',
                question: 'Which age group do you belong to?',
                options: [
                    { value: 'Under 18', label: 'Under 18' },
                    { value: '18-40', label: '18-40' },
                    { value: '40-65', label: '40-65' },
                    { value: '65+', label: '65+' }
                ],
                required: false
            },
            {
                id: 'contact',
                name: 'contact',
                type: 'checkbox-with-fields',
                question: 'Would you like to stay connected?',
                fields: [
                    { id: 'name', name: 'name', label: 'Name', type: 'text', placeholder: 'Enter your name' },
                    { id: 'email', name: 'email', label: 'Email', type: 'email', placeholder: 'Enter your email' }
                ],
                required: false
            }
        ];

        // --- Application State ---
        const appState = {
            currentPage: 0,
            formData: {},
            questionRotationIndex: 0,
            typingTimeout: null,
            displayTimeout: null,
            inactivityTimeout: null, 
            countdownInterval: null,
            isUserActive: false,
            debounceTimer: null,
            adminClickCount: 0,
            adminTimer: null,
            isTyping: false,
            stopRotationPermanently: false,
        };

        // --- Helper Functions ---
        const uuidv4 = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
            const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });

        const debounce = (func, delay) => {
            return (...args) => {
                clearTimeout(appState.debounceTimer);
                appState.debounceTimer = setTimeout(() => func.apply(this, args), delay);
            };
        };

        const updateProgressBar = () => {
            const progress = (appState.currentPage / (surveyQuestions.length - 1)) * 100;
            progressBar.style.width = `${progress}%`;
        };

        const showTemporaryMessage = (message, type = 'info') => {
            const className = type === 'error' ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700';
            statusMessage.textContent = message;
            statusMessage.className = `block p-4 mb-4 rounded-xl text-center font-medium ${className}`;
            statusMessage.style.display = 'block';
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 5000);
        };
        
        const resetRadioAndCheckboxStates = () => {
            const radioButtons = document.querySelectorAll('input[type="radio"]');
            radioButtons.forEach(input => {
                input.checked = false;
            });
            const checkboxes = document.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(input => {
                input.checked = false;
            });
        };

        // --- Question Rotation Logic ---
        const startQuestionRotation = () => {
            if (appState.currentPage !== 0 || appState.stopRotationPermanently) return;
            log("Starting question rotation.");
            rotateQuestions();
        };

        const stopQuestionRotation = () => {
            log("Stopping question rotation.");
            appState.isTyping = false;
            clearTimeout(appState.typingTimeout);
            clearTimeout(appState.displayTimeout);
            appState.typingTimeout = null;
            appState.displayTimeout = null;
        };
        
        // NEW: Inactivity Timer & Countdown Logic
        const cancelAutoSubmit = () => {
            log("User activity detected during countdown. Aborting auto-submit.");
            clearTimeout(appState.inactivityTimeout);
            clearInterval(appState.countdownInterval);
            
            overlayMessage.textContent = "Countdown Canceled. Please continue with your survey.";
            cancelButton.classList.add('hidden');
            
            setTimeout(() => {
                toggleUserInteraction(true);
            }, 1500); // Give user a moment to read the message
        }

        const handleUserActivity = () => {
            // First, cancel any pending auto-submit or countdown
            cancelAutoSubmit();

            log("User activity detected. Resetting inactivity timer.");
            appState.isUserActive = true;
            appState.stopRotationPermanently = true;
            
            if (appState.currentPage !== 0) {
                stopQuestionRotation();
            }

            appState.inactivityTimeout = setTimeout(() => {
                log("User inactive. Triggering auto-submit.");
                autoSubmitSurvey();
            }, config.inactivityTime);
        };

        const typeWriter = (text, i) => {
            const questionElement = questionContainer.querySelector('#rotatingQuestion');
            if (!questionElement) return;

            if (i < text.length) {
                questionElement.textContent += text.charAt(i);
                appState.typingTimeout = setTimeout(() => typeWriter(text, i + 1), config.rotationSpeed);
            } else {
                questionElement.textContent = text;
                appState.isTyping = false;

                if (!appState.isUserActive) {
                    appState.displayTimeout = setTimeout(rotateQuestions, config.rotationDisplayTime);
                }
            }
        };

        const rotateQuestions = () => {
            const rotatingQuestionEl = questionContainer.querySelector('#rotatingQuestion');
            if (!rotatingQuestionEl || appState.stopRotationPermanently) return;
            stopQuestionRotation();
            
            const questionData = surveyQuestions[0];
            const currentQuestion = questionData.rotatingText[appState.questionRotationIndex];
            rotatingQuestionEl.textContent = "";
            appState.questionRotationIndex = (appState.questionRotationIndex + 1) % questionData.rotatingText.length;
            typeWriter(currentQuestion, 0);
        };
        
        const debouncedHandleActivity = debounce(handleUserActivity, config.debounceDelay);

        // --- Survey Page Logic ---
        const renderPage = (pageIndex) => {
            resetRadioAndCheckboxStates();
            
            const questionData = surveyQuestions[pageIndex];
            if (!questionData) return;

            let html = `<label class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;

            switch (questionData.type) {
                case 'textarea':
                    html = `
                        <label id="rotatingQuestion" for="${questionData.id}" class="block text-gray-700 font-semibold mb-2" aria-live="polite">${questionData.question}</label>
                        <textarea
                            id="${questionData.id}"
                            name="${questionData.name}"
                            rows="4"
                            class="shadow-sm resize-none appearance-none border border-gray-300 rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors"
                            placeholder="${questionData.placeholder}"
                            required
                        >${appState.formData[questionData.name] || ''}</textarea>
                        <span id="${questionData.id}Error" class="error-message hidden"></span>
                    `;
                    break;
                case 'emoji-radio':
                    html = `<label id="${questionData.id}Label" class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;
                    html += `<div class="emoji-radio-group flex justify-around items-center space-x-4" role="radiogroup" aria-labelledby="${questionData.id}Label">`;
                    questionData.options.forEach(option => {
                        const checked = appState.formData[questionData.name] === option.value ? 'checked' : '';
                        html += `
                            <input type="radio" id="${questionData.id + option.value}" name="${questionData.name}" value="${option.value}" class="visually-hidden" ${checked} aria-label="${option.label} emoji">
                            <label for="${questionData.id + option.value}" class="flex flex-col items-center p-4 sm:p-6 bg-white border-2 border-transparent rounded-full hover:bg-gray-50 transition-all duration-300 cursor-pointer">
                                <span class="text-4xl sm:text-5xl">${option.emoji}</span>
                                <span class="mt-2 text-gray-500 text-xs sm:text-sm">${option.label}</span>
                            </label>
                        `;
                    });
                    html += `</div>`;
                    html += `<span id="${questionData.id}Error" class="error-message hidden text-center mt-2"></span>`;
                    break;
                case 'number-scale':
                    html = `<label id="${questionData.id}Label" class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;
                    html += `
                        <div id="${questionData.id}Group" class="number-scale-group flex justify-between items-center bg-gray-50 rounded-lg p-4" role="radiogroup" aria-labelledby="${questionData.id}Label">
                            <span class="text-xs text-gray-500">${questionData.labels.min}</span>
                            <div class="flex space-x-2">
                    `;
                    for (let i = questionData.min; i <= questionData.max; i++) {
                        const checked = parseInt(appState.formData[questionData.name]) === i ? 'checked' : '';
                        html += `
                            <input type="radio" id="${questionData.id + i}" name="${questionData.name}" value="${i}" class="visually-hidden" ${checked} aria-label="${i}">
                            <label for="${questionData.id + i}" class="w-10 h-10 flex items-center justify-center text-sm font-medium bg-white rounded-full border border-gray-300 hover:bg-gray-100 transition-colors duration-200 cursor-pointer">${i}</label>
                        `;
                    }
                    html += `
                            </div>
                            <span class="text-xs text-gray-500">${questionData.labels.max}</span>
                        </div>
                    `;
                    html += `<span id="${questionData.id}Error" class="error-message hidden text-center mt-2"></span>`;
                    break;
                case 'star-rating':
                    html = `<label id="${questionData.id}Label" class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;
                    html += `<div id="${questionData.id}Group" class="star-rating flex flex-row-reverse justify-end space-x-1 sm:space-x-2" role="radiogroup" aria-labelledby="${questionData.id}Label">`;
                    for (let i = questionData.max; i >= questionData.min; i--) {
                        const checked = parseInt(appState.formData[questionData.name]) === i ? 'checked' : '';
                        html += `
                            <input type="radio" id="${questionData.id + i}" name="${questionData.name}" value="${i}" ${checked} aria-label="${i} stars">
                            <label for="${questionData.id + i}" class="star">
                                <svg class="w-8 h-8 sm:w-10 sm:h-10 fill-current" viewBox="0 0 24 24"><path d="M12 17.27l6.18 3.73-1.64-7.03 5.46-4.73-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73-1.64 7.03z"/></svg>
                            </label>
                        `;
                    }
                    html += `</div>`;
                    html += `<span id="${questionData.id}Error" class="error-message hidden text-center mt-2"></span>`;
                    break;
                case 'radio-with-other':
                case 'radio':
                    html = `<label id="${questionData.id}Label" class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;
                    html += `<div class="location-radio-group grid grid-cols-1 sm:grid-cols-2 gap-4" role="radiogroup" aria-labelledby="${questionData.id}Label">`;
                    questionData.options.forEach(option => {
                        const checked = appState.formData[questionData.name] === option.value ? 'checked' : '';
                        html += `
                            <div>
                                <input type="radio" id="${questionData.id + option.value}" name="${questionData.name}" value="${option.value}" class="visually-hidden" ${checked} aria-label="${option.label}">
                                <label for="${questionData.id + option.value}" class="block w-full py-4 px-6 bg-white border border-gray-300 rounded-lg text-center font-medium cursor-pointer hover:bg-gray-50 transition-colors duration-200">
                                    ${option.label}
                                </label>
                            </div>
                        `;
                    });
                    html += `</div>`;
                    if (questionData.type === 'radio-with-other' && appState.formData[questionData.name] === 'Other') {
                        const otherValue = appState.formData['otherLocation'] || '';
                        html += `<div class="mt-4"><input type="text" id="otherLocation" name="otherLocation" placeholder="Please specify" value="${otherValue}" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"></div>`;
                        html += `<span id="otherLocationError" class="error-message hidden"></span>`;
                    }
                    html += `<span id="${questionData.id}Error" class="error-message hidden text-center mt-2"></span>`;
                    break;
                case 'checkbox-with-fields':
                    const isChecked = appState.formData.newsletterConsent === 'Yes';
                    const hiddenClass = isChecked ? 'visible-fields' : 'hidden-fields';
                    html = `
                        <p class="text-sm text-gray-500 mb-4">You can optionally provide your contact information to receive updates and news.</p>
                        <div class="flex items-center">
                            <input id="newsletterConsent" name="newsletterConsent" type="checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" ${isChecked ? 'checked' : ''}>
                            <label for="newsletterConsent" class="ml-2 block text-sm text-gray-900">
                                Yes, I would like to subscribe to the newsletter.
                            </label>
                        </div>
                        <div id="contactFields" class="${hiddenClass}">
                    `;
                    questionData.fields.forEach(field => {
                        const value = appState.formData[field.name] || '';
                        html += `
                            <div class="mt-4">
                                <label for="${field.id}" class="block text-sm font-medium text-gray-700">${field.label}</label>
                                <input type="${field.type}" id="${field.id}" name="${field.name}" placeholder="${field.placeholder}" value="${value}" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                                <span id="${field.id}Error" class="error-message hidden"></span>
                            </div>
                        `;
                    });
                    html += `</div>`;
                    break;
            }
            questionContainer.innerHTML = html;

            if (questionData.type === 'checkbox-with-fields') {
                document.getElementById('newsletterConsent').addEventListener('change', (e) => {
                    const contactFields = document.getElementById('contactFields');
                    if (e.target.checked) {
                        contactFields.classList.remove('hidden-fields');
                        contactFields.classList.add('visible-fields');
                    } else {
                        contactFields.classList.remove('visible-fields');
                        contactFields.classList.add('hidden-fields');
                    }
                });
            }
            
            handleUserActivity();

            backButton.style.visibility = appState.currentPage === 0 ? 'hidden' : 'visible';
            nextButton.textContent = (appState.currentPage === surveyQuestions.length - 1) ? 'Submit Survey' : 'Next';

            if (appState.currentPage === 0) {
                startQuestionRotation();
            } else {
                stopQuestionRotation();
            }
            updateProgressBar();
        };

        const saveCurrentPageData = () => {
            const formData = new FormData(form);
            const questionData = surveyQuestions[appState.currentPage];
            
            if (questionData.type === 'checkbox-with-fields') {
                appState.formData.newsletterConsent = formData.get('newsletterConsent') === 'on' ? 'Yes' : 'No';
                appState.formData.name = formData.get('name') || '';
                appState.formData.email = formData.get('email') || '';
            } else if (questionData.type === 'radio-with-other') {
                const selectedOption = formData.get(questionData.name);
                appState.formData[questionData.name] = selectedOption;
                if (selectedOption === 'Other') {
                    appState.formData['otherLocation'] = formData.get('otherLocation') || '';
                } else {
                    delete appState.formData['otherLocation'];
                }
            } else {
                appState.formData[questionData.name] = formData.get(questionData.name);
            }
        };

        const validateCurrentPage = () => {
            const questionData = surveyQuestions[appState.currentPage];
            
            const prevErrorElement = document.getElementById(`${questionData.id}Error`);
            if (prevErrorElement) {
                prevErrorElement.classList.add('hidden');
                const questionGroup = document.getElementById(`${questionData.id}Group`);
                if (questionGroup) {
                    questionGroup.classList.remove('border-2', 'border-red-500');
                }
            }
            if (questionData.type === 'checkbox-with-fields') {
                document.getElementById('name').classList.remove('has-error');
                document.getElementById('email').classList.remove('has-error');
                document.getElementById('nameError').classList.add('hidden');
                document.getElementById('emailError').classList.add('hidden');
            }
            if (questionData.type === 'radio-with-other') {
                const otherLocationInput = document.getElementById('otherLocation');
                if (otherLocationInput) {
                    otherLocationInput.classList.remove('has-error');
                    document.getElementById('otherLocationError').classList.add('hidden');
                }
            }

            let isValid = true;
            let errorMessage = '';

            if (questionData.type === 'checkbox-with-fields') {
                if (appState.formData.newsletterConsent === 'Yes') {
                    const nameInput = document.getElementById('name');
                    const emailInput = document.getElementById('email');
                    const emailRegex = /^\S+@\S+\.\S+$/;

                    if (!nameInput.value.trim()) {
                        isValid = false;
                        document.getElementById('nameError').textContent = 'Name is required.';
                        document.getElementById('nameError').classList.remove('hidden');
                        nameInput.classList.add('has-error');
                    }
                    if (!emailInput.value.trim() || !emailRegex.test(emailInput.value)) {
                        isValid = false;
                        document.getElementById('emailError').textContent = 'A valid email is required.';
                        document.getElementById('emailError').classList.remove('hidden');
                        emailInput.classList.add('has-error');
                    }
                }
            } else if (questionData.required) {
                let value = appState.formData[questionData.name];
                
                if (questionData.type === 'radio-with-other') {
                    if (value === 'Other') {
                        value = appState.formData['otherLocation'];
                        const otherLocationInput = document.getElementById('otherLocation');
                        if (!value || value.trim() === '') {
                            isValid = false;
                            document.getElementById('otherLocationError').textContent = 'Please specify where you are from.';
                            document.getElementById('otherLocationError').classList.remove('hidden');
                            otherLocationInput.classList.add('has-error');
                        }
                    } else if (!value) {
                         isValid = false;
                    }
                } else if (questionData.type === 'textarea') {
                    isValid = value && value.trim() !== '';
                } else {
                    isValid = !!value;
                }

                if (!isValid) {
                    errorMessage = questionData.type === 'textarea' ? 'Please answer this question to continue.' : 'Please select an option to continue.';
                    const errorElement = document.getElementById(`${questionData.id}Error`);
                    if (errorElement) {
                        errorElement.textContent = errorMessage;
                        errorElement.classList.remove('hidden');
                    }

                    const questionGroup = document.getElementById(`${questionData.id}Group`);
                    if (questionGroup) {
                        questionGroup.classList.add('border-2', 'border-red-500');
                    }
                }
            }
            
            return isValid;
        };

        // NEW: Inactivity & Auto-Submit Logic
        const toggleUserInteraction = (enable) => {
            const interactiveElements = form.querySelectorAll('input, button, textarea, label');
            interactiveElements.forEach(el => {
                if (enable) {
                    el.removeAttribute('disabled');
                    el.style.pointerEvents = 'auto';
                } else {
                    el.setAttribute('disabled', 'true');
                    el.style.pointerEvents = 'none';
                }
            });

            if (enable) {
                overlay.classList.remove('visible');
                overlay.style.display = 'none';
            } else {
                overlay.style.display = 'flex';
                setTimeout(() => overlay.classList.add('visible'), 10);
            }
        };

        const autoSubmitSurvey = () => {
            const hasPartialData = Object.keys(appState.formData).length > 0;
            if (hasPartialData) {
                log("User inactive. Initiating auto-submit countdown.");
                toggleUserInteraction(false); 

                let countdown = config.autoSubmitCountdown;
                overlayMessage.textContent = `Auto-submitting in ${countdown}. Interact or press Cancel to stop.`;
                cancelButton.classList.remove('hidden');

                appState.countdownInterval = setInterval(() => {
                    countdown--;
                    overlayMessage.textContent = `Auto-submitting in ${countdown}. Interact or press Cancel to stop.`;
                    
                    if (countdown <= 0) {
                        clearInterval(appState.countdownInterval);
                        log("Countdown finished. Auto-submitting partial survey.");
                        const finalData = { 
                            ...appState.formData, 
                            id: uuidv4(), 
                            timestamp: new Date().toISOString(),
                            isPartial: true
                        };
                        saveSurveyToQueue(finalData);
                        resetSurveyAndUI();
                    }
                }, 1000);
            } else {
                log("No data to submit. Resetting survey to start page.");
                resetSurveyAndUI();
            }
        };
        
        const resetSurveyAndUI = () => {
            clearTimeout(appState.inactivityTimeout);
            clearInterval(appState.countdownInterval);
            form.reset();
            appState.currentPage = 0;
            appState.formData = {};
            appState.isUserActive = false;
            appState.stopRotationPermanently = false;
            renderPage(appState.currentPage);
            toggleUserInteraction(true);
        };
        
        // --- Offline-first and Sync Logic ---
        const getSurveyQueue = () => {
            try {
                const queue = JSON.parse(localStorage.getItem('surveyQueue'));
                return Array.isArray(queue) ? queue.filter(item => !item.isScheduledForRetry) : [];
            } catch (e) {
                console.error("Failed to parse survey queue from localStorage.", e);
                return [];
            }
        };
        
        const saveSurveyToQueue = (data) => {
            log("Saving new survey to local queue.", data);
            const queue = getSurveyQueue();
            queue.push({ ...data, retries: 0 });
            localStorage.setItem('surveyQueue', JSON.stringify(queue));
            updateSyncButtonVisibility();
        };

        const syncData = async () => {
            const queue = getSurveyQueue();
            if (queue.length === 0 || !navigator.onLine) {
                log("Sync not needed or offline.");
                updateSyncButtonVisibility();
                return;
            }
            log(`Starting sync process for ${queue.length} items.`);
            syncButton.textContent = 'Syncing...';
            syncButton.classList.add('sync-loading');
            
            const pendingQueue = getSurveyQueue();
            const successfullySynced = [];
            const failedToSync = [];
            
            for (const surveyData of pendingQueue) {
                try {
                    const response = await fetch('/api/submit-survey', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(surveyData)
                    });
                    if (response.ok) {
                        successfullySynced.push(surveyData);
                        log(`Successfully synced item: ${surveyData.id}`);
                    } else {
                        throw new Error(`API error: ${response.status}`);
                    }
                } catch (error) {
                    log(`Sync failed for item ${surveyData.id}:`, error);
                    failedToSync.push(surveyData);
                }
            }

            let finalQueue = failedToSync.map(item => {
                item.retries++;
                if (item.retries >= config.maxRetries) {
                    log(`Max retries reached for ${item.id}. Dropping.`);
                    return null;
                }
                const delay = config.baseDelay * Math.pow(2, item.retries);
                log(`Scheduling retry for ${item.id} in ${delay / 1000} seconds.`);
                setTimeout(syncData, delay);
                item.isScheduledForRetry = true;
                return item;
            }).filter(Boolean);

            localStorage.setItem('surveyQueue', JSON.stringify(finalQueue));
            syncButton.classList.remove('sync-loading');
            updateSyncButtonVisibility(failedToSync.length > 0);

            if (finalQueue.length === 0) {
                showTemporaryMessage('Sync successful! All data uploaded.');
            } else if (successfullySynced.length > 0) {
                showTemporaryMessage(`Synced ${successfullySynced.length} of ${queue.length} surveys. Some will be retried later.`);
            } else {
                showTemporaryMessage('Sync failed. Please check your internet connection.', 'error');
            }
        };

        const updateSyncButtonVisibility = (hasFailed = false) => {
            const queue = getSurveyQueue();
            if (queue.length > 0 && navigator.onLine) {
                syncButton.classList.remove('hidden');
                syncButton.textContent = `Sync Data (${queue.length})`;
                if (hasFailed) {
                    syncButton.textContent += ' (‚ö†Ô∏è)';
                }
            } else {
                syncButton.classList.add('hidden');
            }
        };
        
        const clearQueue = () => {
            const queue = getSurveyQueue();
            if (queue.length > 0) {
                if (confirm(`Are you sure you want to clear ${queue.length} unsynced submissions? This action cannot be undone.`)) {
                    log("Admin confirmed clear queue. Removing data.");
                    localStorage.removeItem('surveyQueue');
                    updateSyncButtonVisibility();
                    showTemporaryMessage('Unsynced data cleared.');
                }
            } else {
                log("No unsynced data to clear.");
                showTemporaryMessage('No unsynced data to clear.');
            }
        };

        const scheduleDailySync = () => {
            const now = new Date();
            const syncTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 19, 0, 0);
            if (now > syncTime) {
                syncTime.setDate(syncTime.getDate() + 1);
            }
            const delay = syncTime.getTime() - now.getTime();
            log(`Scheduled next sync for ${syncTime.toLocaleString()}. Delay: ${delay / 1000} seconds.`);
            setTimeout(syncData, delay);
        };

        // --- Event Listeners & Initialization ---
        nextButton.addEventListener('click', () => {
            // Explicitly cancel any timers to prevent race conditions
            clearTimeout(appState.inactivityTimeout);
            clearInterval(appState.countdownInterval);
            
            saveCurrentPageData();
            if (!validateCurrentPage()) {
                return;
            }

            if (appState.currentPage === surveyQuestions.length - 1) {
                form.dispatchEvent(new Event('submit', { cancelable: true }));
            } else {
                appState.currentPage++;
                renderPage(appState.currentPage);
            }
        });

        backButton.addEventListener('click', () => {
            if (appState.currentPage > 0) {
                // Explicitly cancel any timers
                clearTimeout(appState.inactivityTimeout);
                clearInterval(appState.countdownInterval);
                appState.currentPage--;
                statusMessage.style.display = 'none';
                renderPage(appState.currentPage);
            }
        });

        syncButton.addEventListener('click', syncData);
        cancelButton.addEventListener('click', cancelAutoSubmit);

        mainTitle.addEventListener('click', () => {
            appState.adminClickCount++;
            if (appState.adminClickCount === 1) {
                appState.adminTimer = setTimeout(() => {
                    appState.adminClickCount = 0;
                }, config.adminClickTimeout);
            } else if (appState.adminClickCount >= config.adminClicksRequired) {
                clearTimeout(appState.adminTimer);
                appState.adminClickCount = 0;
                adminClearButton.classList.toggle('hidden');
                showTemporaryMessage('Admin button toggled.');
            }
        });

        adminClearButton.addEventListener('click', clearQueue);

        form.addEventListener('submit', async (e) => {
            e.preventDefault();

            // Clear the timers explicitly on submission
            clearTimeout(appState.inactivityTimeout);
            clearInterval(appState.countdownInterval);
            
            const finalData = { ...appState.formData, id: uuidv4(), timestamp: new Date().toISOString() };
            log("Form submitted. Saving to queue.", finalData);
            saveSurveyToQueue(finalData);
            
            surveyContent.style.display = 'none';
            statusMessage.style.display = 'block';
            statusMessage.innerHTML = `
                <div class="checkmark-container">
                    <div class="checkmark-circle">
                        <span class="checkmark-icon">&#10003;</span>
                    </div>
                    <h2 class="text-2xl sm:text-3xl font-bold text-gray-800 mt-6">Thank you!</h2>
                    <p class="text-gray-500 mt-2">Your feedback has been submitted.</p>
                </div>
            `;
            
            const rotatingQuestion = surveyQuestions[0].rotatingText[appState.questionRotationIndex];
            const resetDelay = appState.isTyping ? (config.rotationSpeed * rotatingQuestion.length) + 1000 : config.resetTime;

            setTimeout(() => {
                statusMessage.style.display = 'none';
                surveyContent.style.display = 'block';
                resetSurveyAndUI();
            }, resetDelay);
        });

        form.addEventListener('change', (e) => {
            const questionData = surveyQuestions[appState.currentPage];
            const name = e.target.name;
            const value = e.target.value;
            
            const errorElement = document.getElementById(`${e.target.id}Error`) || document.getElementById(`${questionData.id}Error`);
            if (errorElement) {
                errorElement.classList.add('hidden');
                const questionGroup = document.getElementById(`${questionData.id}Group`);
                if (questionGroup) {
                    questionGroup.classList.remove('border-2', 'border-red-500');
                }
            }
            if (e.target.id) {
                const element = document.getElementById(e.target.id);
                if (element) {
                    element.classList.remove('has-error');
                }
            }


            if (questionData.type === 'checkbox-with-fields') {
                saveCurrentPageData();
            } else if (questionData.type === 'radio-with-other') {
                saveCurrentPageData();
                renderPage(appState.currentPage);
            } else {
                appState.formData[name] = value;
            }

            if (e.target.type === 'radio' && questionData.type !== 'radio-with-other') {
                saveCurrentPageData();
                if(validateCurrentPage()){
                    nextButton.click();
                }
            }
        });
        
        document.addEventListener('keydown', (e) => {
            const commentsTextarea = document.getElementById('comments');
            if (commentsTextarea && document.activeElement === commentsTextarea) {
                debouncedHandleActivity();
            }
        });

        document.addEventListener('mousemove', debouncedHandleActivity);
        document.addEventListener('mousedown', debouncedHandleActivity);
        document.addEventListener('touchstart', debouncedHandleActivity);

        window.addEventListener('online', syncData);
        window.addEventListener('offline', updateSyncButtonVisibility);

        renderPage(appState.currentPage);
        updateSyncButtonVisibility();
        scheduleDailySync();
    </script>
</body>
</html>

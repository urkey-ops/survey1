<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sewa International Kiosk Survey</title>
    <link rel="icon" href="/favicon.png" type="image/png">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap');
        :root {
            --sewa-orange: #ff6600;
            --sewa-blue: #004d99;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f0f4f8;
            color: #333;
        }

        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            margin: -1px;
            padding: 0;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }

        .emoji-radio-group input:checked + label,
        .number-scale-group input:checked + label {
            border-color: var(--sewa-orange);
            background-color: #fff;
            transform: scale(1.1);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            color: var(--sewa-orange);
        }

        .emoji-radio-group label,
        .number-scale-group label,
        .location-radio-group label {
            transition: all 0.2s ease-in-out;
            cursor: pointer;
        }

        .star-rating label {
            color: #d1d5db;
            font-size: 3rem;
        }
        
        /* New a11y-friendly star rating CSS */
        .star-rating input {
            display: none;
        }
        .star-rating input:checked ~ label,
        .star-rating input:checked ~ label:hover,
        .star-rating input:checked ~ label:hover ~ label {
            color: #ffc107;
        }
        .star-rating input:not(:checked) ~ label:hover,
        .star-rating input:not(:checked) ~ label:hover ~ label {
            color: #ffc107;
        }

        .location-radio-group input:checked + label {
            background-color: var(--sewa-orange);
            color: white;
            border-color: var(--sewa-orange);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .hidden-fields {
            opacity: 0;
            height: 0;
            pointer-events: none;
            overflow: hidden;
            transition: opacity 0.3s ease-in-out, height 0.3s ease-in-out;
        }

        .visible-fields {
            opacity: 1;
            height: auto;
            pointer-events: auto;
        }

        .loading-bar-container {
            width: 100%;
            background-color: #e2e8f0;
            border-radius: 999px;
            height: 12px;
            overflow: hidden;
        }

        .loading-bar {
            height: 100%;
            background-color: var(--sewa-blue);
            border-radius: 999px;
            transition: width 0.3s ease-in-out;
        }

        .error-message {
            color: #dc2626;
            font-size: 0.875rem;
            margin-top: 0.25rem;
            display: block;
        }

        .has-error {
            border-color: #dc2626 !important;
            box-shadow: 0 0 0 2px rgba(220, 38, 38, 0.5) !important;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease;
            z-index: 50;
        }

        #overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        #cancelButton {
            background-color: #ef4444;
            color: white;
        }

        #cancelButton:hover {
            background-color: #dc2626;
        }

        .checkmark-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .checkmark-circle {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background-color: #22c55e;
            display: flex;
            justify-content: center;
            align-items: center;
            animation: bounceIn 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.27);
        }

        .checkmark-icon {
            color: white;
            font-size: 4rem;
            font-weight: bold;
        }

        @keyframes bounceIn {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            60% {
                transform: scale(1.1);
                opacity: 1;
            }
            100% {
                transform: scale(1);
            }
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4 sm:p-8">
    <main class="w-full max-w-2xl bg-white rounded-2xl shadow-xl overflow-hidden min-h-[500px] flex flex-col">
        <header class="bg-gray-50 border-b border-gray-200 py-4 px-6 flex justify-between items-center relative">
            <h1 id="mainTitle" class="text-xl font-bold text-gray-800 cursor-pointer">Customer Feedback</h1>
            <div class="absolute inset-x-0 bottom-0">
                <div id="progressBarContainer" class="loading-bar-container">
                    <div id="progressBar" class="loading-bar" style="width: 0;"></div>
                </div>
            </div>
            <div class="flex items-center space-x-2">
                <button id="syncButton" class="hidden px-3 py-1 bg-blue-500 text-white text-sm font-medium rounded-lg hover:bg-blue-600 transition-colors">Sync Data</button>
                <button id="adminClearButton" class="hidden px-3 py-1 bg-red-500 text-white text-sm font-medium rounded-lg hover:bg-red-600 transition-colors">Clear</button>
            </div>
        </header>

        <section id="surveyContent" class="p-6 sm:p-8 flex-1 flex flex-col justify-center">
            <div id="statusMessage" class="hidden"></div>
            <form id="surveyForm" class="space-y-6 flex-1 flex flex-col">
                <div id="questionContainer" class="flex-1 flex flex-col justify-center">
                    </div>
                <div class="flex justify-between items-center pt-4">
                    <button id="backButton" type="button" class="px-6 py-3 bg-gray-200 text-gray-700 font-bold rounded-xl shadow hover:bg-gray-300 transition-colors">Back</button>
                    <button id="nextButton" type="button" class="px-6 py-3 bg-orange-500 text-white font-bold rounded-xl shadow hover:bg-orange-600 transition-colors">Next</button>
                </div>
            </form>
        </section>

        <div id="overlay">
            <div class="p-8 bg-white rounded-lg shadow-xl text-center">
                <p id="overlayMessage" class="text-xl font-bold mb-4">Survey auto-submitting in <span id="countdown">5</span> seconds...</p>
                <button id="cancelButton" class="px-6 py-2 rounded-lg font-medium hidden">Cancel</button>
            </div>
        </div>
    </main>

    <script>
        // --- Core Application Logic ---
        const form = document.getElementById('surveyForm');
        const statusMessage = document.getElementById('statusMessage');
        const syncButton = document.getElementById('syncButton');
        const adminClearButton = document.getElementById('adminClearButton');
        const mainTitle = document.getElementById('mainTitle');
        const nextButton = document.getElementById('nextButton');
        const backButton = document.getElementById('backButton');
        const questionContainer = document.getElementById('questionContainer');
        const surveyContent = document.getElementById('surveyContent');
        const overlay = document.getElementById('overlay');
        const overlayMessage = document.getElementById('overlayMessage');
        const countdownSpan = document.getElementById('countdown');
        const cancelButton = document.getElementById('cancelButton');
        const progressBar = document.getElementById('progressBar');

        const DEBUG_MODE = true;
        const log = (message, ...args) => {
            if (DEBUG_MODE) {
                console.log(`[DEBUG] ${message}`, ...args);
            }
        };

        const config = {
            rotationSpeed: 50,
            rotationDisplayTime: 4000,
            resetTime: 5000,
            adminClicksRequired: 5,
            adminClickTimeout: 3000,
            inactivityTime: 30000,
            autoSubmitCountdown: 5,
            debounceDelay: 200,
            maxRetries: 5,
            baseDelay: 500,
        };
        
        const API_ENDPOINT = '/api/submit-survey';
        const localStorageKey = 'surveySubmissions';

        const surveyQuestions = [
            {
                id: 'comments',
                name: 'comments',
                type: 'textarea',
                question: '1. What did you like about your visit today?',
                placeholder: 'Type your comments here...',
                required: true,
                rotatingText: [
                    "1. What did you like about your visit today?",
                    "1. What could we do better during your next visit?",
                    "1. Do you have any general comments or suggestions?",
                    "1. What was the most memorable part of your experience?"
                ]
            },
            {
                id: 'satisfaction',
                name: 'satisfaction',
                type: 'emoji-radio',
                question: '2. Overall, how satisfied were you with your visit today?',
                options: [
                    { value: 'Sad', label: 'Sad', emoji: '😞' },
                    { value: 'Neutral', label: 'Neutral', emoji: '😐' },
                    { value: 'Happy', label: 'Happy', emoji: '😊' }
                ],
                required: true
            },
            {
                id: 'cleanliness',
                name: 'cleanliness',
                type: 'number-scale',
                question: '3. How would you rate the cleanliness of the facility?',
                min: 1,
                max: 5,
                labels: { min: '1 (Poor)', max: '5 (Excellent)' },
                required: true
            },
            {
                id: 'staff_friendliness',
                name: 'staff_friendliness',
                type: 'star-rating',
                question: '4. How friendly was the volunteer staff?',
                min: 1,
                max: 5,
                required: true
            },
            {
                id: 'location',
                name: 'location',
                type: 'radio-with-other',
                question: 'Where are you visiting from today?',
                options: [
                    { value: 'Lilburn/Gwinnett County', label: 'Lilburn/Gwinnett County' },
                    { value: 'Greater Atlanta Area', label: 'Greater Atlanta Area' },
                    { value: 'Georgia (outside Atlanta)', label: 'Georgia (outside GA)' },
                    { value: 'United States (outside GA)', label: 'United States (outside GA)' },
                    { value: 'Canada', label: 'Canada' },
                    { value: 'India', label: 'India' },
                    { value: 'Other', label: 'Other' }
                ],
                required: false
            },
            {
                id: 'age',
                name: 'age',
                type: 'radio',
                question: 'Which age group do you belong to?',
                options: [
                    { value: 'Under 18', label: 'Under 18' },
                    { value: '18-40', label: '18-40' },
                    { value: '40-65', label: '40-65' },
                    { value: '65+', label: '65+' }
                ],
                required: false
            },
            {
                id: 'contact',
                name: 'contact',
                type: 'custom-contact',
                question: 'Help us stay in touch.',
                required: false,
                fields: [
                    { id: 'name', name: 'name', label: 'Name', type: 'text', placeholder: 'Enter your name' },
                    { id: 'newsletterConsent', name: 'newsletterConsent', label: 'Yes, I want to subscribe to updates', type: 'checkbox', placeholder: '' },
                    { id: 'email', name: 'email', label: 'Email', type: 'email', placeholder: 'Enter your email' }
                ]
            }
        ];

        const appState = {
            currentPage: 0,
            formData: {},
            questionRotationIndex: 0,
            typingTimeout: null,
            displayTimeout: null,
            inactivityTimeout: null,
            countdownInterval: null,
            isUserActive: false,
            debounceTimer: null,
            adminClickCount: 0,
            adminTimer: null,
            isTyping: false,
            stopRotationPermanently: false,
            stopRotationOnCompletion: false,
        };

        // --- Helper Functions ---
        const uuidv4 = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
            const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });

        const debounce = (func, delay) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func(...args), delay);
            };
        };

        const updateProgressBar = () => {
            const progress = (appState.currentPage / (surveyQuestions.length - 1)) * 100;
            progressBar.style.width = `${progress}%`;
        };

        const showTemporaryMessage = (message, type = 'info') => {
            const className = type === 'error' ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700';
            statusMessage.textContent = message;
            statusMessage.className = `block p-4 mb-4 rounded-xl text-center font-medium ${className}`;
            statusMessage.style.display = 'block';
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 5000);
        };
        
        const resetRadioAndCheckboxStates = () => {
            const radioButtons = document.querySelectorAll('input[type="radio"]');
            radioButtons.forEach(input => {
                input.checked = false;
            });
            const checkboxes = document.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(input => {
                input.checked = false;
            });
        };

        // --- Question Rotation Logic ---
        const startQuestionRotation = () => {
            if (appState.currentPage !== 0 || appState.stopRotationPermanently) return;
            log("Starting question rotation.");
            rotateQuestions();
        };

        const stopQuestionRotation = () => {
            log("Stopping question rotation.");
            appState.isTyping = false;
            clearTimeout(appState.typingTimeout);
            clearTimeout(appState.displayTimeout);
            appState.typingTimeout = null;
            appState.displayTimeout = null;
        };

        // Inactivity Timer & Countdown Logic
        const clearCountdown = () => {
            clearInterval(appState.countdownInterval);
            appState.countdownInterval = null;
            if (countdownSpan) {
                countdownSpan.textContent = config.autoSubmitCountdown;
            }
        };

        const cancelAutoSubmit = () => {
            log("User activity detected during countdown. Aborting auto-submit.");
            clearTimeout(appState.inactivityTimeout);
            clearCountdown();

            overlayMessage.textContent = "Countdown Canceled. Please continue with your survey.";
            cancelButton.classList.add('hidden');

            handleUserActivity();

            setTimeout(() => {
                toggleUserInteraction(true);
                overlayMessage.innerHTML = 'Survey auto-submitting in <span id="countdown">5</span> seconds...';
            }, 1500);
        }

        const handleUserActivity = () => {
            clearTimeout(appState.inactivityTimeout);
            clearCountdown();

            log("User activity detected. Resetting inactivity timer.");
            appState.isUserActive = true;
            appState.stopRotationPermanently = true;

            if (appState.currentPage !== 0) {
                appState.stopRotationOnCompletion = true;
            }

            appState.inactivityTimeout = setTimeout(() => {
                log("User inactive. Triggering auto-submit.");
                autoSubmitSurvey();
            }, config.inactivityTime);
        };

        const typeWriter = (text, i) => {
            const questionElement = questionContainer.querySelector('#rotatingQuestion');
            if (!questionElement) {
                log("Rotation element not found, stopping rotation.");
                return;
            }

            if (i < text.length) {
                questionElement.textContent += text.charAt(i);
                appState.typingTimeout = setTimeout(() => typeWriter(text, i + 1), config.rotationSpeed);
            } else {
                questionElement.textContent = text;
                appState.isTyping = false;
        
                if (appState.stopRotationOnCompletion) {
                    log("Typing completed, stopping rotation as requested by user interaction.");
                    stopQuestionRotation();
                    appState.stopRotationOnCompletion = false; 
                } else if (!appState.isUserActive) {
                    appState.displayTimeout = setTimeout(rotateQuestions, config.rotationDisplayTime);
                }
            }
        };

        const rotateQuestions = () => {
            const rotatingQuestionEl = questionContainer.querySelector('#rotatingQuestion');
            if (!rotatingQuestionEl || appState.stopRotationPermanently) return;
            stopQuestionRotation();

            const questionData = surveyQuestions[0];
            const currentQuestion = questionData.rotatingText[appState.questionRotationIndex];
            rotatingQuestionEl.textContent = "";
            appState.questionRotationIndex = (appState.questionRotationIndex + 1) % questionData.rotatingText.length;
            typeWriter(currentQuestion, 0);
        };

        const debouncedHandleActivity = debounce(handleUserActivity, config.debounceDelay);
        const debouncedValidate = debounce(runValidation, 500);

        // --- Survey Page Logic ---
        const renderPage = (pageIndex) => {
            resetRadioAndCheckboxStates();

            const questionData = surveyQuestions[pageIndex];
            if (!questionData) return;

            let html = '';

            switch (questionData.type) {
                case 'textarea':
                    html = `
                        <label id="rotatingQuestion" for="${questionData.id}" class="block text-gray-700 font-semibold mb-2" aria-live="polite">${questionData.question}</label>
                        <textarea
                            id="${questionData.id}"
                            name="${questionData.name}"
                            rows="4"
                            class="shadow-sm resize-none appearance-none border border-gray-300 rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors"
                            placeholder="${questionData.placeholder}"
                            required
                        >${appState.formData[questionData.name] || ''}</textarea>
                        <span id="${questionData.id}Error" class="error-message hidden"></span>
                    `;
                    break;
                case 'emoji-radio':
                    html = `<label id="${questionData.id}Label" class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;
                    html += `<div class="emoji-radio-group flex justify-around items-center space-x-4" role="radiogroup" aria-labelledby="${questionData.id}Label">`;
                    questionData.options.forEach(option => {
                        const checked = appState.formData[questionData.name] === option.value ? 'checked' : '';
                        html += `
                            <input type="radio" id="${questionData.id + option.value}" name="${questionData.name}" value="${option.value}" class="visually-hidden" ${checked} aria-label="${option.label} emoji">
                            <label for="${questionData.id + option.value}" class="flex flex-col items-center p-4 sm:p-6 bg-white border-2 border-transparent rounded-full hover:bg-gray-50 transition-all duration-300 cursor-pointer">
                                <span class="text-4xl sm:text-5xl mb-2">${option.emoji}</span>
                                <span class="text-sm font-medium text-gray-600">${option.label}</span>
                            </label>
                        `;
                    });
                    html += `</div><span id="${questionData.id}Error" class="error-message hidden mt-2 block"></span>`;
                    break;
                case 'number-scale':
                    html = `<label id="${questionData.id}Label" class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;
                    html += `<div class="number-scale-group flex justify-between items-center space-x-2" role="radiogroup" aria-labelledby="${questionData.id}Label">`;
                    for (let i = questionData.min; i <= questionData.max; i++) {
                        const checked = parseInt(appState.formData[questionData.name]) === i ? 'checked' : '';
                        html += `
                            <input type="radio" id="${questionData.id + i}" name="${questionData.name}" value="${i}" class="visually-hidden" ${checked} aria-label="Rating of ${i}">
                            <label for="${questionData.id + i}" class="flex flex-col items-center justify-center w-12 h-12 sm:w-14 sm:h-14 bg-white border-2 border-transparent rounded-full font-bold text-gray-700 hover:bg-gray-50 transition-colors duration-300 cursor-pointer">
                                <span>${i}</span>
                            </label>
                        `;
                    }
                    html += `</div>
                             <div class="flex justify-between text-sm mt-2 text-gray-500">
                                 <span>${questionData.labels.min}</span>
                                 <span>${questionData.labels.max}</span>
                             </div>
                             <span id="${questionData.id}Error" class="error-message hidden mt-2 block"></span>
                            `;
                    break;
                case 'star-rating':
                    html = `<label id="${questionData.id}Label" class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;
                    // A11y-friendly star rating HTML
                    html += `<div class="star-rating flex justify-center mt-2" role="radiogroup" aria-labelledby="${questionData.id}Label">`;
                    for (let i = questionData.min; i <= questionData.max; i++) {
                        const checked = parseInt(appState.formData[questionData.name]) === i ? 'checked' : '';
                        html += `
                            <input type="radio" id="${questionData.id + i}" name="${questionData.name}" value="${i}" class="visually-hidden" ${checked} aria-label="${i} stars">
                            <label for="${questionData.id + i}" class="star text-4xl sm:text-5xl pr-1">★</label>
                        `;
                    }
                    html += `</div><span id="${questionData.id}Error" class="error-message hidden mt-2 block"></span>`;
                    break;
                case 'radio-with-other':
                    html = `<label id="${questionData.id}Label" class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;
                    html += `<div class="location-radio-group grid grid-cols-2 sm:grid-cols-3 gap-2" role="radiogroup" aria-labelledby="${questionData.id}Label">`;
                    questionData.options.forEach(option => {
                        const checked = appState.formData[questionData.name] === option.value ? 'checked' : '';
                        html += `
                            <input type="radio" id="${questionData.id + option.value}" name="${questionData.name}" value="${option.value}" class="visually-hidden" ${checked}>
                            <label for="${questionData.id + option.value}" class="px-3 py-3 text-center text-sm sm:text-base font-medium border-2 border-gray-300 rounded-lg cursor-pointer transition-colors duration-200">${option.label}</label>
                        `;
                    });
                    html += `</div>
                            <div id="other-location-container" class="mt-4 ${appState.formData[questionData.name] === 'Other' ? '' : 'hidden'}">
                                <input type="text" id="other_location_text" name="other_location" class="shadow-sm appearance-none border border-gray-300 rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors" placeholder="Please specify your location" value="${appState.formData['other_location'] || ''}">
                                <span id="other_location_textError" class="error-message hidden mt-1"></span>
                            </div>
                            <span id="${questionData.id}Error" class="error-message hidden mt-2 block"></span>`;
                    break;
                case 'radio':
                    html = `<label id="${questionData.id}Label" class="block text-gray-700 font-semibold mb-2">${questionData.question}</label>`;
                    html += `<div class="grid grid-cols-2 sm:grid-cols-4 gap-2" role="radiogroup" aria-labelledby="${questionData.id}Label">`;
                    questionData.options.forEach(option => {
                        const checked = appState.formData[questionData.name] === option.value ? 'checked' : '';
                        html += `
                            <input type="radio" id="${questionData.id + option.value}" name="${questionData.name}" value="${option.value}" class="visually-hidden" ${checked}>
                            <label for="${questionData.id + option.value}" class="px-3 py-3 text-center text-sm sm:text-base font-medium border-2 border-gray-300 rounded-lg cursor-pointer transition-colors duration-200">${option.label}</label>
                        `;
                    });
                    html += `</div><span id="${questionData.id}Error" class="error-message hidden mt-2 block"></span>`;
                    break;
                case 'custom-contact':
                    const nameValue = appState.formData['name'] || '';
                    const newsletterConsentChecked = appState.formData['newsletterConsent'] === 'Yes' ? 'checked' : '';
                    const emailValue = appState.formData['email'] || '';
                    const emailFieldVisibleClass = newsletterConsentChecked ? 'visible-fields' : 'hidden-fields';

                    html = `
                        <div class="space-y-4">
                            <div>
                                <label for="name" class="block text-gray-700 font-semibold mb-2">Name</label>
                                <input type="text" id="name" name="name" class="shadow-sm appearance-none border border-gray-300 rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors" placeholder="Enter your name" value="${nameValue}" required>
                                <span id="nameError" class="error-message hidden"></span>
                            </div>
                            <div class="flex items-center">
                                <input type="checkbox" id="newsletterConsent" name="newsletterConsent" value="Yes" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" ${newsletterConsentChecked}>
                                <label for="newsletterConsent" class="ml-2 block text-gray-700">Yes, I want to subscribe to updates</label>
                            </div>
                            <div id="email-field-container" class="${emailFieldVisibleClass}">
                                <label for="email" class="block text-gray-700 font-semibold mb-2">Email</label>
                                <input type="email" id="email" name="email" class="shadow-sm appearance-none border border-gray-300 rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors" placeholder="Enter your email" value="${emailValue}">
                                <span id="emailError" class="error-message hidden"></span>
                            </div>
                        </div>
                    `;
                    break;
            }

            questionContainer.innerHTML = html;
            updateProgressBar();

            if (pageIndex === 0) {
                if (!appState.isUserActive) {
                    startQuestionRotation();
                }
            } else {
                stopQuestionRotation();
            }

            if (pageIndex === surveyQuestions.length - 1) {
                nextButton.textContent = 'Submit Survey';
            } else {
                nextButton.textContent = 'Next';
            }

            backButton.style.visibility = pageIndex === 0 ? 'hidden' : 'visible';
            setupEventListeners();
        };

        const clearValidationErrors = () => {
            const errorSpans = questionContainer.querySelectorAll('.error-message');
            errorSpans.forEach(span => {
                span.classList.add('hidden');
                span.textContent = '';
            });
            const errorInputs = questionContainer.querySelectorAll('.has-error');
            errorInputs.forEach(input => {
                input.classList.remove('has-error');
            });
        };

        const showValidationError = (fieldId, message) => {
            const errorSpan = document.getElementById(`${fieldId}Error`);
            const fieldInput = document.getElementById(fieldId);
            if (errorSpan) {
                errorSpan.textContent = message;
                errorSpan.classList.remove('hidden');
            }
            if (fieldInput) {
                fieldInput.classList.add('has-error');
            }
            if (!fieldInput && errorSpan) {
                const parentGroup = errorSpan.closest('.emoji-radio-group, .number-scale-group, .star-rating, .location-radio-group');
                if (parentGroup) {
                    parentGroup.classList.add('has-error');
                }
            }
        };

        const validatePage = () => {
            const questionData = surveyQuestions[appState.currentPage];
            const errors = {};

            const currentPageData = {};
            const inputs = questionContainer.querySelectorAll('input, textarea');
            inputs.forEach(input => {
                if (input.type === 'radio' && input.checked) {
                    currentPageData[input.name] = input.value;
                } else if (input.type === 'checkbox') {
                    currentPageData[input.name] = input.checked ? 'Yes' : 'No';
                } else if (input.type !== 'radio') {
                    currentPageData[input.name] = input.value;
                }
            });

            if (questionData.type === 'textarea') {
                const value = currentPageData[questionData.name]?.trim();
                if (questionData.required && (!value || value.length === 0)) {
                    errors[questionData.id] = 'This field is required.';
                }
            } else if (questionData.type === 'emoji-radio' || questionData.type === 'number-scale' || questionData.type === 'radio' || questionData.type === 'star-rating') {
                if (questionData.required && !currentPageData[questionData.name]) {
                    errors[questionData.id] = 'Please make a selection.';
                }
            } else if (questionData.type === 'radio-with-other') {
                const selectedValue = currentPageData[questionData.name];
                const otherLocationValue = currentPageData['other_location']?.trim();

                if (selectedValue === 'Other' && (!otherLocationValue || otherLocationValue.length === 0)) {
                    errors['other_location_text'] = 'Please specify your location.';
                }
            } else if (questionData.type === 'custom-contact') {
                const nameValue = currentPageData['name']?.trim();
                const newsletterConsent = currentPageData['newsletterConsent'] === 'Yes';
                const emailValue = currentPageData['email']?.trim();

                if (!nameValue || nameValue.length === 0) {
                    errors['name'] = 'Name is required.';
                }

                if (newsletterConsent && (!emailValue || emailValue.length === 0)) {
                    errors['email'] = 'Email is required for subscription.';
                } else if (emailValue && !/^\S+@\S+\.\S+$/.test(emailValue)) {
                    errors['email'] = 'Please enter a valid email address.';
                }
            }

            clearValidationErrors();
            if (Object.keys(errors).length > 0) {
                for (const fieldId in errors) {
                    showValidationError(fieldId, errors[fieldId]);
                }
                return false;
            } else {
                Object.assign(appState.formData, currentPageData);
                log("Current form data:", appState.formData);
                return true;
            }
        };

        function runValidation() {
            validatePage();
        }

        const toggleEmailFieldVisibility = (isVisible) => {
            const emailContainer = document.getElementById('email-field-container');
            const emailInput = document.getElementById('email');

            if (isVisible) {
                emailContainer.classList.remove('hidden-fields');
                emailContainer.classList.add('visible-fields');
                emailInput.setAttribute('required', 'true');
            } else {
                emailContainer.classList.remove('visible-fields');
                emailContainer.classList.add('hidden-fields');
                emailInput.removeAttribute('required');
                emailInput.value = '';
            }
        };

        const handleNextQuestion = () => {
            if (validatePage()) {
                if (appState.currentPage < surveyQuestions.length - 1) {
                    appState.currentPage++;
                    renderPage(appState.currentPage);
                } else {
                    submitSurveyAndHandleCompletion();
                }
            }
        };

        const setupEventListeners = () => {
            const questionData = surveyQuestions[appState.currentPage];

            const inputs = questionContainer.querySelectorAll('input, textarea');
            inputs.forEach(input => {
                input.removeEventListener('input', debouncedHandleActivity);
                input.removeEventListener('change', debouncedHandleActivity);
                input.removeEventListener('blur', debouncedValidate);
                input.removeEventListener('change', debouncedValidate);
            });
            form.removeEventListener('keydown', debouncedHandleActivity);
            form.removeEventListener('click', debouncedHandleActivity);

            if (questionData.type === 'textarea') {
                const textarea = document.getElementById('comments');
                if (textarea) {
                    textarea.addEventListener('focus', () => {
                        appState.stopRotationOnCompletion = true;
                    });
                    textarea.addEventListener('blur', () => {
                        startQuestionRotation();
                        debouncedValidate();
                    });
                }
            } else if (questionData.type === 'radio-with-other') {
                const otherRadio = document.getElementById('locationOther');
                const otherLocationContainer = document.getElementById('other-location-container');
                const allRadios = document.querySelectorAll('input[name="location"]');

                allRadios.forEach(radio => {
                    radio.addEventListener('change', () => {
                        debouncedValidate();
                        if (radio.value === 'Other') {
                            otherLocationContainer.classList.remove('hidden');
                            nextButton.style.display = 'block';
                        } else {
                            otherLocationContainer.classList.add('hidden');
                            const otherInput = otherLocationContainer.querySelector('input');
                            if (otherInput) otherInput.value = '';
                            handleNextQuestion();
                        }
                    });
                });
            } else if (questionData.type === 'custom-contact') {
                const newsletterCheckbox = document.getElementById('newsletterConsent');
                if (newsletterCheckbox) {
                    newsletterCheckbox.addEventListener('change', (e) => {
                        toggleEmailFieldVisibility(e.target.checked);
                        debouncedValidate();
                    });
                }
                if (newsletterCheckbox) {
                    toggleEmailFieldVisibility(newsletterCheckbox.checked);
                }
            } else if (['emoji-radio', 'number-scale', 'star-rating', 'radio'].includes(questionData.type)) {
                const radioButtons = questionContainer.querySelectorAll('input[type="radio"]');
                radioButtons.forEach(radio => {
                    radio.addEventListener('change', () => {
                        debouncedValidate();
                        handleNextQuestion();
                    });
                });
            }

            inputs.forEach(input => {
                input.addEventListener('input', debouncedHandleActivity);
                input.addEventListener('change', debouncedHandleActivity);

                if (input.type === 'text' || input.type === 'textarea' || input.type === 'email') {
                    input.addEventListener('blur', debouncedValidate);
                } else if (input.type === 'radio' || input.type === 'checkbox') {
                    input.addEventListener('change', debouncedValidate);
                }
            });

            form.addEventListener('keydown', debouncedHandleActivity);
            form.addEventListener('click', debouncedHandleActivity);
        };

        // --- Data Storage and API Communication ---
        const getStoredSubmissions = () => {
            try {
                const submissions = JSON.parse(localStorage.getItem(localStorageKey) || '[]');
                return Array.isArray(submissions) ? submissions : [];
            } catch (e) {
                console.error("Failed to parse submissions from localStorage", e);
                return [];
            }
        };

        const storeSubmission = (submission) => {
            const submissions = getStoredSubmissions();
            submissions.push(submission);
            localStorage.setItem(localStorageKey, JSON.stringify(submissions));
        };

        const removeSyncedSubmissions = (syncedIds) => {
            const submissions = getStoredSubmissions();
            const remaining = submissions.filter(sub => !syncedIds.includes(sub.id));
            localStorage.setItem(localStorageKey, JSON.stringify(remaining));
        };

        const submitSurveyAPI = async (data) => {
            const response = await fetch(API_ENDPOINT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data),
            });
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        };

        const syncData = async () => {
            const submissions = getStoredSubmissions();
            if (submissions.length === 0) {
                log("No offline submissions to sync.");
                return;
            }

            showTemporaryMessage(`Syncing ${submissions.length} offline submissions...`);
            const successfullySyncedIds = [];
            let networkErrorOccurred = false;

            for (const submission of submissions) {
                try {
                    await submitSurveyAPI(submission);
                    successfullySyncedIds.push(submission.id);
                    log(`Successfully synced submission ID: ${submission.id}`);
                } catch (error) {
                    if (error.message.includes('HTTP error')) {
                        log(`Server error for submission ID: ${submission.id}. Retrying later.`, error);
                    } else {
                        log(`Network error for submission ID: ${submission.id}. Sync will resume on next attempt.`, error);
                        networkErrorOccurred = true;
                        break;
                    }
                }
            }

            if (successfullySyncedIds.length > 0) {
                removeSyncedSubmissions(successfullySyncedIds);
                showTemporaryMessage(`Synced ${successfullySyncedIds.length} submissions.`, 'success');
            }

            if (networkErrorOccurred) {
                showTemporaryMessage('Sync failed. Please check connection.', 'error');
            }
        };

        const autoSubmitSurvey = () => {
            if (appState.currentPage === 0 && Object.keys(appState.formData).length === 0) {
                log("User inactive on first page with no data. Resetting survey.");
                resetSurvey();
                return;
            }

            log("Starting auto-submit countdown.");
            let countdown = config.autoSubmitCountdown;
            countdownSpan.textContent = countdown;
            toggleUserInteraction(false);
            overlay.classList.add('visible');
            cancelButton.classList.remove('hidden');

            cancelButton.addEventListener('click', cancelAutoSubmit, { once: true });

            appState.countdownInterval = setInterval(() => {
                countdown--;
                if (countdownSpan) {
                    countdownSpan.textContent = countdown;
                }
                if (countdown <= 0) {
                    clearCountdown();
                    toggleUserInteraction(false, "Submitting...");
                    submitSurveyAndHandleCompletion();
                }
            }, 1000);
        };

        const submitSurveyAndHandleCompletion = async () => {
            const submission = {
                id: uuidv4(),
                timestamp: new Date().toISOString(),
                data: appState.formData
            };
            await storeSubmission(submission);
            await syncData();
            showCompletionScreen();
        };

        const showCompletionScreen = () => {
            surveyContent.innerHTML = `
                <div class="checkmark-container min-h-[300px]">
                    <div class="checkmark-circle">
                        <div class="checkmark-icon">✓</div>
                    </div>
                    <h2 class="text-2xl font-bold text-gray-800 mt-6">Thank You!</h2>
                    <p class="text-gray-600 mt-2">Your feedback has been submitted successfully.</p>
                </div>
            `;
            setTimeout(() => {
                resetSurvey();
            }, config.resetTime);
        };

        const resetSurvey = () => {
            log("Resetting survey.");
            appState.currentPage = 0;
            appState.formData = {};
            appState.isUserActive = false;
            appState.stopRotationPermanently = false;
            overlay.classList.remove('visible');
            overlayMessage.innerHTML = 'Survey auto-submitting in <span id="countdown">5</span> seconds...';
            cancelButton.classList.add('hidden');
            form.reset();
            clearCountdown();
            renderPage(appState.currentPage);

            toggleUserInteraction(true);
            handleUserActivity();
        };

        const toggleUserInteraction = (enable, message = "") => {
            if (enable) {
                surveyContent.classList.remove('pointer-events-none', 'opacity-50');
                overlay.classList.remove('visible');
            } else {
                surveyContent.classList.add('pointer-events-none', 'opacity-50');
                if (message) {
                    overlayMessage.innerHTML = message;
                    overlay.classList.add('visible');
                }
            }
        };

        // --- Event Handlers ---
        nextButton.addEventListener('click', (e) => {
            e.preventDefault();
            handleNextQuestion();
        });

        backButton.addEventListener('click', (e) => {
            e.preventDefault();
            if (appState.currentPage > 0) {
                appState.currentPage--;
                renderPage(appState.currentPage);
            }
        });

        mainTitle.addEventListener('click', () => {
            appState.adminClickCount++;
            if (appState.adminTimer) {
                clearTimeout(appState.adminTimer);
            }
            appState.adminTimer = setTimeout(() => {
                appState.adminClickCount = 0;
            }, config.adminClickTimeout);

            if (appState.adminClickCount === config.adminClicksRequired) {
                log("Admin mode activated!");
                showTemporaryMessage("Admin mode activated.");
                syncButton.classList.remove('hidden');
                adminClearButton.classList.remove('hidden');
                appState.adminClickCount = 0;
                clearTimeout(appState.adminTimer);
            }
        });

        syncButton.addEventListener('click', syncData);
        adminClearButton.addEventListener('click', () => {
            localStorage.clear();
            showTemporaryMessage("Local data cleared.", "success");
            resetSurvey();
        });

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            renderPage(appState.currentPage);
            handleUserActivity();
            syncData();
        });
    </script>
</body>
</html>
